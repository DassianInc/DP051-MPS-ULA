<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Gnt-plugin-TaskContextMenu'>/**
</span>@class Gnt.plugin.TaskContextMenu
@extends Ext.menu.Menu

Plugin (ptype = 'gantt_taskcontextmenu') for showing a context menu when right clicking a task:

{@img gantt/images/context-menu.png}

You can add it to your gantt chart like this:

    var gantt = Ext.create('Gnt.panel.Gantt', {
        plugins             : [
            Ext.create(&quot;Gnt.plugin.TaskContextMenu&quot;)
        ],
        ...
    })


To customize the content of the menu, subclass this plugin and provide your own implementation of the `createMenuItems` method.
You can also customize various handlers for menu items, like `addTaskAbove`, `deleteTask` etc. For example:

    Ext.define('MyProject.plugin.TaskContextMenu', {
        extend     : 'Gnt.plugin.TaskContextMenu',

        createMenuItems : function () {
            return this.callParent().concat({
                text        : 'My handler',

                handler     : this.onMyHandler,
                scope       : this
            });

            this.on('beforeshow', this.onMyBeforeShow, this);
        },

        onMyHandler : function () {
            // the task on which the right click have occured
            var task        = this.rec;

            ...
        },

        onMyBeforeShow : function() {
            // Allow delete only based on some condition
            var isDeleteAllowed = this.rec.get('AllowDelete');

            this.down('#deleteTask').setVisible(isDeleteAllowed);
        }
    });

    var gantt = Ext.create('Gnt.panel.Gantt', {
        selModel : new Ext.selection.TreeModel({ ignoreRightMouseSelection : false }),
        plugins             : [
            Ext.create(&quot;MyProject.plugin.TaskContextMenu&quot;)
        ],
        ...
    })

Note that when using right click to show the menu you should set the 'ignoreRightMouseSelection' to false on your selection model (as seen in the source above).

*/
Ext.define(&quot;Gnt.plugin.TaskContextMenu&quot;, {
    extend                  : 'Ext.menu.Menu',
    alias                   : 'plugin.gantt_taskcontextmenu',
<span id='Gnt-plugin-TaskContextMenu-property-ptype'>    // ptype isn't filled automatically, because we do not extend AbstractPlugin
</span>    ptype                   : 'gantt_taskcontextmenu',
    mixins                  : ['Ext.AbstractPlugin', 'Gnt.mixin.Localizable'],
<span id='Gnt-plugin-TaskContextMenu-property-lockableScope'>    lockableScope           : 'top',
</span>
    requires                : ['Gnt.model.Task'],

<span id='Gnt-plugin-TaskContextMenu-property-plain'>    plain                   : true,
</span>
<span id='Gnt-plugin-TaskContextMenu-cfg-triggerEvent'>    /**
</span>     * @cfg {String/String[]} triggerEvent
     * The event(s) upon which the menu shall be shown. Might be provided as an array of multiple event names.
     * Defaults to 'itemcontextmenu' and 'containercontextmenu', meaning the menu is shown when right-clicking a row or task bar
     * and when right-clicking an empty area in the grid.
     * You can change this to 'taskcontextmenu' if you want the menu to be shown only when right clicking a task bar.
     */
    triggerEvent            : ['itemcontextmenu', 'containercontextmenu'],

<span id='Gnt-plugin-TaskContextMenu-property-hideEvent'>    hideEvent               : null,
</span>
<span id='Gnt-plugin-TaskContextMenu-cfg-l10n'>    /**
</span>     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - newTaskText         : 'New task'
     - deleteTask          : 'Delete task(s)'
     - editLeftLabel       : 'Edit left label'
     - editRightLabel      : 'Edit right label'
     - add                 : 'Add...'
     - deleteDependency    : 'Delete dependency...'
     - addTaskAbove        : 'Task above'
     - addTaskBelow        : 'Task below'
     - addMilestone        : 'Milestone'
     - addSubtask          : 'Sub-task'
     - addSuccessor        : 'Successor'
     - addPredecessor      : 'Predecessor'
     - splitTask           : 'Split task'
     */

    grid                    : null,

<span id='Gnt-plugin-TaskContextMenu-property-rec'>    /**
</span>     * @property {Gnt.model.Task} rec The task model, for which the menu was activated
     */
    rec                     : null,

<span id='Gnt-plugin-TaskContextMenu-property-triggerEventXY'>    triggerEventXY          : null,
</span><span id='Gnt-plugin-TaskContextMenu-property-lastHighlightedItem'>    lastHighlightedItem     : null,
</span>
<span id='Gnt-plugin-TaskContextMenu-property-taskEditorInjected'>    taskEditorInjected      : false,
</span>
    config                  : {
<span id='Gnt-plugin-TaskContextMenu-cfg-splitDuration'>        /**
</span>         * @cfg {Number} splitDuration Split duration to be used when &quot;Split task&quot; menu item is called.
         * Set this to zero to enable automatic split duration calculation depending on active zoom level.
         * In this mode the split duration is calculated as a clicked tick duration restricted by
         * {@link #minSplitDuration} and {@link #maxSplitDuration} values.
         */
        splitDuration           : 0,
<span id='Gnt-plugin-TaskContextMenu-cfg-splitDurationUnit'>        /**
</span>         * @cfg {String} splitDurationUnit Split duration unit to be used when &quot;Split task&quot; menu item is called
         * See {@link #splitDuration} for details.
         */
        splitDurationUnit       : 'd',

<span id='Gnt-plugin-TaskContextMenu-cfg-maxSplitDuration'>        /**
</span>         * @cfg {Number} maxSplitDuration Maximum allowed split duration (use {@link #maxSplitDurationUnit} to define unit for this value).
         * The value is used upon automatic split duration calculation is enabled (see {@link #splitDuration} for details).
         */
        maxSplitDuration        : 1,
<span id='Gnt-plugin-TaskContextMenu-cfg-maxSplitDurationUnit'>        /**
</span>         * @cfg {String} maxSplitDurationUnit Maximum allowed split duration unit.
         * See {@link #maxSplitDuration} for details.
         */
        maxSplitDurationUnit    : 'd',

<span id='Gnt-plugin-TaskContextMenu-cfg-minSplitDuration'>        /**
</span>         * @cfg {Number} minSplitDuration Minimum allowed split duration (use {@link #minSplitDurationUnit} to define unit for this value).
         * The value is used upon automatic split duration calculation is enabled (see {@link #splitDuration} for details).
         */
        minSplitDuration        : 1,
<span id='Gnt-plugin-TaskContextMenu-cfg-minSplitDurationUnit'>        /**
</span>         * @cfg {String} minSplitDurationUnit Minimum allowed split duration unit.
         * See {@link #minSplitDuration} for details.
         */
        minSplitDurationUnit    : 'h'
    },

<span id='Gnt-plugin-TaskContextMenu-method-getState'>    getState    : function () {
</span>        if (this.rendered) {
            return this.callParent(arguments);
        }
    },


<span id='Gnt-plugin-TaskContextMenu-method-isNotProject'>    isNotProject : function (task) {
</span>        return !task || !task.isProject;
    },


<span id='Gnt-plugin-TaskContextMenu-method-createMenuItems'>    /**
</span>     * This method is being called during plugin initialization. Override if you need to customize the items in the menu.
     * The method should return an array of menu items, which will be used as the value of the `items` property.
     *
     * Each menu item is decorated with an itemId property for testability.
     *
     * @return {Array}
     */
    createMenuItems : function () {

        var me = this;

        return [
            {
                handler      : this.deleteTask,
                requiresTask : true,
                itemId       : 'deleteTask',
                text         : this.L('deleteTask')
            },
            {
                handler         : this.editLeftLabel,
                requiresTask    : true,
                itemId          : 'editLeftLabel',
                text            : this.L('editLeftLabel'),
                isValidAction   : function (task) {
                    return me.grid.getSchedulingView().getLeftEditor() &amp;&amp; !task.isReadOnly();
                }
            },
            {
                handler         : this.editRightLabel,
                requiresTask    : true,
                itemId          : 'editRightLabel',
                text            : this.L('editRightLabel'),
                isValidAction   : function (task) {
                    return me.grid.getSchedulingView().getRightEditor() &amp;&amp; !task.isReadOnly();
                }
            },
            {
                handler         : this.toggleMilestone,
                requiresTask    : true,
                itemId          : 'toggleMilestone',
                text            : this.L('convertToMilestone'),
                isValidAction   : function (task) {
                        return this.isNotProject(task) &amp;&amp; !task.isReadOnly();
                }
            },
            {
                handler       : this.splitTask,
                requiresTask  : true,
                itemId        : 'splitTask',
                isValidAction : function(task, triggerDomEvent) {
                    return task &amp;&amp;
                          !task.isReadOnly() &amp;&amp;
                           task.getStartDate() &amp;&amp;
                           task.getEndDate() &amp;&amp;
                          !task.isMilestone() &amp;&amp;
                           task.isLeaf() &amp;&amp;
                           triggerDomEvent &amp;&amp;
                           triggerDomEvent.getTarget('.sch-gantt-task-bar');
                },
                text         : this.L('splitTask')
            },
            {
                text   : this.L('add'),
                itemId : 'addTaskMenu',
                menu   : {
                    plain : true,
                    defaults : { scope : this },
                    items : [
                        {
                            handler      : this.addTaskAboveAction,
                            requiresTask : true,
                            itemId       : 'addTaskAbove',
                            text         : this.L('addTaskAbove'),
                            isValidAction : function (task) {
                                return me.isNotProject(task) &amp;&amp; !task.parentNode.isReadOnly();
                            }
                        },
                        {
                            handler      : this.addTaskBelowAction,
                            requiresTask : true,
                            itemId       : 'addTaskBelow',
                            text         : this.L('addTaskBelow'),
                            isValidAction : function (task) {
                                return me.isNotProject(task) &amp;&amp; !task.parentNode.isReadOnly();
                            }
                        },
                        {
                            handler      : this.addMilestone,
                            itemId       : 'addMilestone',
                            requiresTask : true,
                            text         : this.L('addMilestone'),
                            isValidAction : function (task) {
                                return !task.isReadOnly();
                            }
                        },
                        {
                            handler      : this.addSubtask,
                            requiresTask : true,
                            itemId       : 'addSubtask',
                            text         : this.L('addSubtask'),
                            isValidAction : function (task) {
                                return !task.isReadOnly();
                            }
                        },
                        {
                            handler      : this.addSuccessor,
                            requiresTask : true,
                            itemId       : 'addSuccessor',
                            text         : this.L('addSuccessor'),
                            isValidAction : function (task) {
                                return me.isNotProject(task) &amp;&amp; !task.parentNode.isReadOnly();
                            }
                        },
                        {
                            handler      : this.addPredecessor,
                            requiresTask : true,
                            itemId       : 'addPredecessor',
                            text         : this.L('addPredecessor'),
                            isValidAction : function (task) {
                                return me.isNotProject(task) &amp;&amp; !task.parentNode.isReadOnly();
                            }
                        }
                    ]
                }
            },
            {
                text         : this.L('deleteDependency'),
                requiresTask : true,
                itemId       : 'deleteDependencyMenu',

                isValidAction : function(task) {
                    return task &amp;&amp; task.getAllDependencies().length &gt; 0;
                },

                menu : {
                    plain : true,

                    listeners : {
                        beforeshow : this.populateDependencyMenu,

                        // highlight dependencies on mouseover of the menu item
                        mouseover  : this.onDependencyMouseOver,

                        // unhighlight dependencies on mouseout of the menu item
                        mouseleave : this.onDependencyMouseOut,

                        scope      : this
                    }
                }
            }
        ];
    },


<span id='Gnt-plugin-TaskContextMenu-method-buildMenuItems'>    // backward compat
</span>    buildMenuItems  : function () {
        this.items = this.createMenuItems();
    },


<span id='Gnt-plugin-TaskContextMenu-method-initComponent'>    initComponent : function () {
</span>        var triggerEvent    = this.triggerEvent,
            hideEvent       = this.hideEvent;

        this.defaults       = this.defaults || {};
        this.defaults.scope = this;

        if (triggerEvent) {
            if (!Ext.isArray(triggerEvent)) {
                triggerEvent = [ triggerEvent ];
            }
        }

        this.triggerEvent   = triggerEvent;

        if (hideEvent) {
            if (!Ext.isArray(hideEvent)) {
                hideEvent   = [ hideEvent ];
            }
        }

        // In IE task context menu cannot be blured on click in scheduling area,
        // because we prevent row focusing to avoid loosing scroll position
        // (in Sch.mixin.TimelinePanel.patchNavigationModel method).
        // So we help to do it by hiding the menu on &quot;itemclick&quot; event
        // TODO: get rid of this after IE focusing issue is solved
        if (Ext.isIE) {
            hideEvent       = hideEvent || [];
            hideEvent.push('itemclick');
        }

        this.hideEvent      = hideEvent;

        this.buildMenuItems();

        this.callParent(arguments);
    },


<span id='Gnt-plugin-TaskContextMenu-method-init'>    init : function (grid) {
</span>        this.grid = grid;
        this.bindTriggerEvent();
        this.bindHideEvent();
    },


<span id='Gnt-plugin-TaskContextMenu-method-bindTriggerEvent'>    bindTriggerEvent : function () {
</span>        var triggerEvent    = this.triggerEvent,
            grid            = this.grid || this.getCmp();

        if (triggerEvent) {
            for (var i = triggerEvent.length - 1; i &gt;= 0; i--) {
                grid.on(triggerEvent[i], this.onTriggerEvent, this);
            }
        }
    },


<span id='Gnt-plugin-TaskContextMenu-method-bindHideEvent'>    bindHideEvent : function () {
</span>        var hideEvent   = this.hideEvent,
            grid        = this.grid || this.getCmp();

        if (hideEvent) {
            for (var i = hideEvent.length - 1; i &gt;= 0; i--) {
                grid.on(hideEvent[i], this.onHideEvent, this);
            }
        }
    },

<span id='Gnt-plugin-TaskContextMenu-method-onHideEvent'>    onHideEvent : function () {
</span>        this.hide();
    },

<span id='Gnt-plugin-TaskContextMenu-method-populateDependencyMenu'>    populateDependencyMenu : function (menu) {
</span>        // HACK http://www.sencha.com/forum/showthread.php?296359-Disabled-Menuitem-still-shows-its-menu&amp;p=1082213#post1082213
        if (menu.up('menuitem').isDisabled()) return false;

        var grid            = this.grid,
            taskStore       = grid.getTaskStore(),
            dependencies    = this.rec.getAllDependencies(),
            depStore        = grid.dependencyStore;

        menu.removeAll();

        if (!dependencies.length) return false;

        var taskId      = this.rec.getId() || this.rec.internalId;

        Ext.Array.forEach(dependencies, function (dependency) {
            var fromId  = dependency.getSourceId(),
                task    = taskStore.getModelById(fromId == taskId ? dependency.getTargetId() : fromId);

            if (task) {
                menu.add({
                    dependency  : dependency,
                    text        : Ext.util.Format.ellipsis(Ext.String.htmlEncode(task.getName()), 30),
                    scope       : this,
                    handler     : function (menuItem) {
                        depStore.remove(menuItem.dependency);
                    },
                    disabled : this.rec.isReadOnly()
                });
            }
        }, this);
    },


<span id='Gnt-plugin-TaskContextMenu-method-onDependencyMouseOver'>    onDependencyMouseOver : function (menu, item, e) {
</span>        if (item) {
            var schedulingView = this.grid.getSchedulingView();

            if (this.lastHighlightedItem) {
                schedulingView.unhighlightDependency(this.lastHighlightedItem.dependency);
            }

            this.lastHighlightedItem = item;

            schedulingView.highlightDependency(item.dependency);
        }
    },


<span id='Gnt-plugin-TaskContextMenu-method-onDependencyMouseOut'>    onDependencyMouseOut : function (menu, e) {
</span>        if (this.lastHighlightedItem) {
            this.grid.getSchedulingView().unhighlightDependency(this.lastHighlightedItem.dependency);
        }
    },


<span id='Gnt-plugin-TaskContextMenu-method-onTriggerEvent'>    onTriggerEvent : function () {
</span>        var context     = this.getTriggerEventContext.apply(this, arguments);

        this.activateMenu(context.record, context.e);
    },

<span id='Gnt-plugin-TaskContextMenu-method-getTriggerEventContext'>    getTriggerEventContext : function () {
</span>        var result  = {};

        // loop over arguments forward searching for the task
        for (var i = 0, l = arguments.length - 1; i &lt;= l; i++) {
            if (arguments[i] instanceof Gnt.model.Task) {
                result.record = arguments[i];
                break;
            }
        }

        // loop over arguments backward searching for the event
        for (i = arguments.length - 1; i &gt;= 0; i--) {
            if (arguments[i] instanceof Ext.EventObjectImpl) {
                result.e    = arguments[i];
                break;
            }
        }

        return result;
    },


<span id='Gnt-plugin-TaskContextMenu-method-activateMenu'>    activateMenu : function (rec, e) {
</span>        // Do not show menu for the root node of task store and in readonly mode of the gantt chart
        if (this.grid.isReadOnly() || this.grid.taskStore.getRootNode() === rec) {
            return;
        }

        e.stopEvent();

        this.rec = rec;
        this.triggerEventXY = e.getXY();
        this.configureMenuItems(e);

        this.showAt(e.getXY());

        // force the menu focusing
        // w/o this the menu will never hide when clicking other grid rows
        this.focus();
    },


<span id='Gnt-plugin-TaskContextMenu-method-addTaskEditorEntry'>    addTaskEditorEntry : function () {
</span>        this.insert(0, {
            text            : this.L('taskInformation'),
            itemId          : 'taskEditor',
            requiresTask    : true,
            handler         : function () {
                this.grid.getTaskEditor(this.rec).showTask(this.rec);
            },
            isValidAction   : function (task) {
                return this.grid.getTaskEditor(task);
            },
            scope           : this
        });

        // remember that we added the entry
        this.taskEditorInjected = true;
    },


<span id='Gnt-plugin-TaskContextMenu-method-setTaskEditorEntryLabel'>    setTaskEditorEntryLabel : function (task) {
</span>        var taskEditor = this.down('#taskEditor');

        if (task &amp;&amp; taskEditor) {
            taskEditor.setText(task.isProject ? this.L('projectInformation') : this.L('taskInformation'));
        }
    },


<span id='Gnt-plugin-TaskContextMenu-method-configureMenuItems'>    configureMenuItems : function (triggerEvent) {
</span>
        var rec      = this.rec;

        if (this.grid.getTaskEditor()) {
            if (!this.taskEditorInjected) this.addTaskEditorEntry();

            // set proper task editor menu entry title
            this.setTaskEditorEntryLabel(rec);
        }

        Ext.Array.forEach(this.query('menuitem'), function (item) {
            // the menu entry has yo be disabled:
            // - if it requires a task to be selected
            // - or it's not valid (dependends on its &quot;isValidAction&quot; result)
            var disable = (item.requiresTask &amp;&amp; !rec) ||
                (item.isValidAction &amp;&amp; !item.isValidAction.call(item.scope || item, rec, triggerEvent));

            item.setDisabled(disable);
        });

        var toggleMilestone = this.down('#toggleMilestone');

        if (rec &amp;&amp; toggleMilestone) {
            toggleMilestone.setText(rec.isMilestone() ? this.L('convertToRegular') : this.L('convertToMilestone'));
        }
    },


<span id='Gnt-plugin-TaskContextMenu-method-copyTask'>    copyTask : function (original) {
</span>        var model = this.grid.getTaskStore().model;

        var newTask = new model({
            leaf : true
        });

        newTask.setPercentDone(0);
        newTask.setName(this.L('newTaskText', this.texts));
        newTask.set(newTask.startDateField, (original &amp;&amp; original.getStartDate()) || null);
        newTask.set(newTask.endDateField, (original &amp;&amp; original.getEndDate()) || null);
        newTask.set(newTask.durationField, (original &amp;&amp; original.getDuration()) || null);
        newTask.set(newTask.durationUnitField, (original &amp;&amp; original.getDurationUnit()) || 'd');
        return newTask;
    },


    // Actions follow below
    // ---------------------------------------------

<span id='Gnt-plugin-TaskContextMenu-method-addTaskAbove'>    /**
</span>     * Handler for the &quot;add task above&quot; menu item
     */
    addTaskAbove : function (newTask) {
        var task = this.rec;

        if (task) {
            task.addTaskAbove(newTask);
        } else {
            this.grid.taskStore.getRootNode().appendChild(newTask);
        }
    },

<span id='Gnt-plugin-TaskContextMenu-method-addTaskBelow'>    /**
</span>     * Handler for the &quot;add task below&quot; menu item
     */
    addTaskBelow : function (newTask) {
        var task = this.rec;

        if (task) {
            task.addTaskBelow(newTask);
        } else {
            this.grid.taskStore.getRootNode().appendChild(newTask);
        }
    },

<span id='Gnt-plugin-TaskContextMenu-method-deleteTask'>    /**
</span>     * Handler for the &quot;delete task&quot; menu item
     */
    deleteTask : function () {
        var selModel = this.grid.getSelectionModel();

        selModel.selected.each(function(task) { task.parentNode ? task.parentNode.removeSubtask(task) : task.remove(); });
    },

<span id='Gnt-plugin-TaskContextMenu-method-editLeftLabel'>    /**
</span>     * Handler for the &quot;edit left label&quot; menu item
     */
    editLeftLabel : function () {
        this.grid.getSchedulingView().editLeftLabel(this.rec);
    },

<span id='Gnt-plugin-TaskContextMenu-method-editRightLabel'>    /**
</span>     * Handler for the &quot;edit right label&quot; menu item
     */
    editRightLabel : function () {
        this.grid.getSchedulingView().editRightLabel(this.rec);
    },


<span id='Gnt-plugin-TaskContextMenu-method-addTaskAboveAction'>    /**
</span>     * Handler for the &quot;add task above&quot; menu item
     */
    addTaskAboveAction : function () {
        this.addTaskAbove(this.copyTask(this.rec));
    },


<span id='Gnt-plugin-TaskContextMenu-method-addTaskBelowAction'>    /**
</span>     * Handler for the &quot;add task below&quot; menu item
     */
    addTaskBelowAction : function () {
        this.addTaskBelow(this.copyTask(this.rec));
    },


<span id='Gnt-plugin-TaskContextMenu-method-addSubtask'>    /**
</span>     * Handler for the &quot;add subtask&quot; menu item
     */
    addSubtask : function () {
        var task = this.rec;
        task.addSubtask(this.copyTask(task));
    },

<span id='Gnt-plugin-TaskContextMenu-method-addSuccessor'>    /**
</span>     * Handler for the &quot;add successor&quot; menu item
     */
    addSuccessor : function () {
        var task = this.rec;
        task.addSuccessor(this.copyTask(task));
    },

<span id='Gnt-plugin-TaskContextMenu-method-addPredecessor'>    /**
</span>     * Handler for the &quot;add predecessor&quot; menu item
     */
    addPredecessor : function () {
        var task = this.rec;
        task.addPredecessor(this.copyTask(task));
    },


<span id='Gnt-plugin-TaskContextMenu-method-addMilestone'>    /**
</span>     * Handler for the &quot;add milestone&quot; menu item
     */
    addMilestone : function () {
        var task = this.rec,
            newTask = this.copyTask(task);

        task.addTaskBelow(newTask);
        newTask.setStartEndDate(task.getEndDate(), task.getEndDate());
    },

<span id='Gnt-plugin-TaskContextMenu-method-toggleMilestone'>    /**
</span>     * Handler for the &quot;Convert to milestone&quot; menu item
     */
    toggleMilestone : function () {
        if (this.rec.isMilestone()) {
            this.rec.convertToRegular();
        } else {
            this.rec.convertToMilestone();
        }
    },

<span id='Gnt-plugin-TaskContextMenu-method-getSplitDate'>    /**
</span>     * @protected
     * Returns a date for the task splitting.
     * Returns start date of the tick being clicked if the tick duration is less than {@link #maxSplitDuration} or {@link #maxSplitDuration} is zero.
     * When the tick duration is greater than {@link #maxSplitDuration} returns `context.date` rounded based on active time axis resolution unit.
     *
     * Override this method if you want to implement another way of a split date receiving.
     * See also: {@link #getSplitDuration}, {@link #getSplitDurationUnit}.
     * @param  {Object}                 context             Split call context
     * @param  {Gnt.model.Task}         context.task        Task being split
     * @param  {Array}                  context.pos         Click position. Array containing [x, y] coordinates of mouse click.
     * @param  {Date}                   context.date        Date corresponding to the click position.
     * @param  {Sch.model.TimeAxisTick} context.tick        Time axis tick corresponding to the click position.
     * @param  {Sch.data.TimeAxis}      context.timeAxis    Time axis instance.
     * @return {Date}      Returns a date to be used to split.
     */
    getSplitDate : function (context) {
        var task        = context.task,
            date        = context.date,
            tick        = context.tick,
            timeAxis    = context.timeAxis,
            maxDuration = this.getMaxSplitDuration(),
            result;

        if (tick) {
            result      = tick.getStartDate();
            // we use tick duration if it's less than maximal allowed split size
            if (maxDuration) {
                maxDuration = task.getUnitConverter().convertDurationToMs(maxDuration, this.getMaxSplitDurationUnit());

                if (maxDuration &lt; tick.getEndDate() - tick.getStartDate()) result = null;
            }
        }

        // otherwise round clicked datetime relative to task start using active time axis resolution unit
        return result || timeAxis.roundDate(date, task.getStartDate());
    },

<span id='Gnt-plugin-TaskContextMenu-method-getSplitDuration'>    /**
</span>     * @protected
     * Returns a duration for the task splitting.
     * Returns duration of the tick being clicked constrained by {@link #minSplitDuration} and {@link #maxSplitDuration} values.
     * Override this method if you want to implement another way of a split date receiving.
     * See also: {@link #getSplitDate}, {@link #getSplitDurationUnit}.
     * @param  {Object}                 context             Split call context
     * @param  {Gnt.model.Task}         context.task        Task being split
     * @param  {Array}                  context.pos         Click position. Array containing [x, y] coordinates of mouse click.
     * @param  {Date}                   context.date        Date corresponding to the click position.
     * @param  {Sch.model.TimeAxisTick} context.tick        Time axis tick corresponding to the click position.
     * @param  {Sch.data.TimeAxis}      context.timeAxis    Time axis instance.
     * @return {Number}      Returns split duration.
     */
    getSplitDuration : function (context) {
        if (this.splitDuration) return this.splitDuration;

        var task    = context.task,
            pos     = context.pos,
            date    = context.date,
            tick    = context.tick;

        if (tick) {
            // let's get tick length in MS as initial duration
            var result      = task.calculateDuration(tick.getStartDate(), tick.getEndDate(), Sch.util.Date.MILLI),
                converter   = task.getUnitConverter(),
                minDuration = this.getMinSplitDuration(),
                maxDuration = this.getMaxSplitDuration();

            // if we have to constrain duration
            if (minDuration || maxDuration) {
                if (maxDuration) {
                    result = Math.min(result, converter.convertDurationToMs(maxDuration, this.getMaxSplitDurationUnit()));
                }
                if (minDuration) {
                    result = Math.max(result, converter.convertDurationToMs(minDuration, this.getMinSplitDurationUnit()));
                }
            }

            // turn duration to proper duration unit
            return converter.convertMSDurationToUnit(result, this.getSplitDurationUnit(task, pos, date, tick));
        }
    },

<span id='Gnt-plugin-TaskContextMenu-method-getSplitDurationUnit'>    /**
</span>     * @protected
     * Returns a duration unit for the task splitting.
     * Returns {@link #splitDurationUnit} when {@link #splitDuration} provided or `ms`.
     * Override this method if you want to implement another way of the split date receiving.
     * See also: {@link #getSplitDate}, {@link #getSplitDuration}.
     * @param  {Object}                 context             Split call context
     * @param  {Gnt.model.Task}         context.task        Task being split
     * @param  {Array}                  context.pos         Click position. Array containing [x, y] coordinates of mouse click.
     * @param  {Date}                   context.date        Date corresponding to the click position.
     * @param  {Sch.model.TimeAxisTick} context.tick        Time axis tick corresponding to the click position.
     * @param  {Sch.data.TimeAxis}      context.timeAxis    Time axis instance.
     * @return {String}      Returns split duration unit.
     */
    getSplitDurationUnit : function (context) {
        // if we have constant &quot;splitDuration&quot; set then we use &quot;splitDurationUnit&quot;
        // otherwise let's use milliseconds
        return this.splitDuration ? this.splitDurationUnit : Sch.util.Date.MILLI;
    },

<span id='Gnt-plugin-TaskContextMenu-method-splitTask'>    /**
</span>     * Handler for the &quot;Split task&quot; menu item
     */
    splitTask : function () {
        var me          = this,
            view        = me.grid.getSchedulingView(),
            cursorDate  = view.getDateFromX(me.triggerEventXY[0]),
            timeAxis    = view.timeAxis;

        var context     = {
            task        : me.rec,
            pos         : me.triggerEventXY,
            date        : cursorDate,
            timeAxis    : timeAxis,
            tick        : timeAxis.getAt(Math.floor(timeAxis.getTickFromDate(cursorDate)))
        };

        context.task.split(me.getSplitDate(context), me.getSplitDuration(context), me.getSplitDurationUnit(context));
    }
});
</pre>
</body>
</html>
