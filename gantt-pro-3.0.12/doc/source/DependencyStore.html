<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Gnt-data-DependencyStore'>/**
</span>
@class Gnt.data.DependencyStore
@extends Ext.data.Store

 A class representing a collection of dependencies between the tasks in the {@link Gnt.data.TaskStore}.
 Contains a collection of {@link Gnt.model.Dependency} records.

## Custom validation

You can subclass this Store class like any other Ext JS class and add your own custom validation for Dependencies:

    Ext.define('MyDependencyStore', {
        extend              : 'Gnt.data.DependencyStore',

        // Override this method to provide custom logic defining what constitutes a valid dependency
        getDependencyError  : function (from, to) {
            // Support default validation rules
            var error = this.callParent(arguments);
            if (error) return error;

            // Example: Don`t allow links between tasks of type A, to tasks with type B
            var isDepInput = from instanceof Ext.data.Model;
            var sourceTask = isDepInput ? from.getSourceTask() : this.getTaskById(from);
            var targetTask = isDepInput ? from.getTargetTask() : this.getTaskById(to);

            // Let`s return a custom error code -100 for such case (it must be a negative value)
            if (sourceTask.getType() !== 'A' || targetTask.getType() !== 'B') return -100;

            // No errors
            return 0;
        },

        ...
    })

*/
Ext.define('Gnt.data.DependencyStore', {
    extend          : 'Ext.data.Store',

    mixins          : [
        'Sch.data.mixin.UniversalModelGetter'
    ],

<span id='Gnt-data-DependencyStore-property-model'>    model           : 'Gnt.model.Dependency',
</span>
<span id='Gnt-data-DependencyStore-property-storeId'>    storeId         : 'dependencies',
</span>    alias           : 'store.gantt_dependencystore',

<span id='Gnt-data-DependencyStore-property-taskStore'>    /**
</span>     * @property {Gnt.data.TaskStore} taskStore The task store to which this dependency store is associated.
     * Usually is configured automatically, by the task store itself.
     */
    taskStore       : null,

<span id='Gnt-data-DependencyStore-property-methodsCache'>    methodsCache    : null,
</span>
<span id='Gnt-data-DependencyStore-cfg-strictDependencyValidation'>    /**
</span>     * @cfg {Boolean} strictDependencyValidation A boolean flag indicating whether a strict validation of dependencies should be applied.
     * This mode will detect indirect cycles between parent-child relationships.
     * For example, the following cases will be considered as invalid (here `P1`, `P2`, `P3` are parent tasks and `T1`, `T2`, `T3` - their children respectively):

                P1 =========
                T1 ++++++          P2 =========
                                   T2    +++++        P3 ===============
                                                      T3 +++++++++++++++

     * These cases will be considered as cycles:
     *
     * - if we have dependency `P1----&gt;P2` then dependency `T2----&gt;P1` will be invalid
     * - if we have dependency `P1----&gt;T2` then dependency `T2----&gt;T1` will be invalid
     * - if we have dependency `P1----&gt;P2` then dependency `T2----&gt;T1` will be invalid
     * - if we have dependencies `P1----&gt;P2----&gt;P3` then dependency `T3----&gt;T1` will be invalid
     * - if we have dependency `P1----&gt;T2` then dependency `P2----&gt;T1` will be invalid
     * - if we have dependencies `P1----&gt;T2` `P2----&gt;T3` then dependency `P3----&gt;T1` will be invalid
     * - if we have dependencies `T1----&gt;P2` `T2----&gt;P3` then dependency `T3----&gt;P1` will be invalid
     *
     * and these cases will be treated as transitivity (or duplicating) dependency when {@link #transitiveDependencyValidation} is set to `True`:
     *
     * - if we have dependency `P1----&gt;P2` then dependency `T1----&gt;P2` will be invalid
     * - if we have dependency `P1----&gt;T2` then dependency `T1----&gt;T2` will be invalid
     * - if we have dependency `P1----&gt;P2` then dependency `T1----&gt;T2` will be invalid
     * - if we have dependencies `P1----&gt;P2----&gt;P3` then dependency `T1----&gt;T3` will be invalid
     * - if we have dependency `P1----&gt;T2` then dependency `T1----&gt;P2` will be invalid
     * - if we have dependencies `P1----&gt;T2` `P2----&gt;T3` then dependency `T1----&gt;P3` will be invalid
     * - if we have dependencies `T1----&gt;P2` `T2----&gt;P3` then dependency `P1----&gt;T3` will be invalid
     */
    strictDependencyValidation  : false,

<span id='Gnt-data-DependencyStore-cfg-transitiveDependencyValidation'>    /**
</span>     * @cfg {Boolean} transitiveDependencyValidation When set to true, alternative routes between tasks are considered invalid.
     * For example if we have dependencies `A----&gt;B----&gt;C` and `D----&gt;C` then dependency `A----&gt;D` will be treated as invalid
     * because it builds an alternative route from task `A` to task `C`.
     *
     * When {@link #strictDependencyValidation} is `True` this setting also enables detecting transitivity between groups of tasks.
     * Please see {@link #strictDependencyValidation} description for examples.
     */
    transitiveDependencyValidation  : false,

<span id='Gnt-data-DependencyStore-property-ignoreInitial'>    // this flag is used to ignore the initial &quot;add&quot; events, that are fired when data is provided in the config
</span>    ignoreInitial               : true,

<span id='Gnt-data-DependencyStore-property-isLoadingRecords'>    // we set it to true to catch `datachanged` event from `loadData` method and ignore this event from records' CRUD operations
</span>    isLoadingRecords            : false,

<span id='Gnt-data-DependencyStore-cfg-allowedDependencyTypes'>    /**
</span>     * @cfg {String[]} allowedDependencyTypes
     *
     * Represents a list of the dependency types that are allowed in this store. Any {@link Gnt.panel.Gantt} panel associated with this store
     * will query this store for this information. If set to `null` (the default value) all types of dependencies are allowed.
     * To restrict the allowed dependencies set, provide it as an array of strings, corresponding to the names in the {@link Gnt.model.Dependency#Type} enumerable.
     *
     * For example:
     *
     *          allowedDependencyTypes : [ 'StartToEnd', 'EndToEnd' ]
     *
     */
    allowedDependencyTypes      : null,

<span id='Gnt-data-DependencyStore-property-proxy'>    proxy   : 'memory',
</span>
<span id='Gnt-data-DependencyStore-cfg-allowParentTaskDependencies'>    /**
</span>     * @cfg {Boolean} allowParentTaskDependencies Set to `false` to disallow dependencies involving parent tasks.
     */
    allowParentTaskDependencies : true,

<span id='Gnt-data-DependencyStore-method-constructor'>    constructor : function(config) {
</span>        config  = config || {};


        // subscribing to the CRUD before parent constructor - in theory, that should guarantee, that our listeners
        // will be called first (before any other listeners, that could be provided in the &quot;listeners&quot; config)
        // and state in other listeners will be correct

        this.callParent([config]);

        this.init();

        this.ignoreInitial      = false;
    },

<span id='Gnt-data-DependencyStore-method-init'>    init : function() {
</span>        this.methodsCache   = {};

        this.on({
            add         : this.onDependencyAdd,
            update      : this.onDependencyUpdate,

            load        : this.onDependencyLoad,
            // look like it is not required since we're updating cache on record CRUD and they fire `datachanged` event
            // this mean when we catch this event cache should be already updated
            datachanged : this.onDependencyDataChanged,

            // seems we can't use &quot;bulkremove&quot; event, because one can listen to `remove` event on the task store
            // and expect correct state in it
            remove      : this.onDependencyRemove,
            clear       : this.onDependencyStoreClear,
            priority    : 100,

            scope       : this
        });
    },

<span id='Gnt-data-DependencyStore-method-onDependencyLoad'>    onDependencyLoad    : function () {
</span>        var taskStore = this.getTaskStore();
        taskStore &amp;&amp; taskStore.fillTasksWithDepInfo();
    },

<span id='Gnt-data-DependencyStore-method-onDependencyDataChanged'>    onDependencyDataChanged : function () {
</span>        var taskStore = this.getTaskStore();
        if (this.isLoadingRecords &amp;&amp; taskStore) taskStore.fillTasksWithDepInfo();
    },


<span id='Gnt-data-DependencyStore-method-loadRecords'>    loadRecords    : function () {
</span>        this.isLoadingRecords = true;
        this.callParent(arguments);
        this.isLoadingRecords = false;
    },


<span id='Gnt-data-DependencyStore-method-scheduleTask'>    // Checks if a provided task is fully scheduled and sets its empty start/end/duration fields otherwise.
</span>    scheduleTask : function (task) {
        var taskStore = this.getTaskStore(),
            startDate = task.getStartDate(),
            endDate   = task.getEndDate();

        if (!startDate || !endDate) {
            task.beginEdit();

            // if task doesn't have a start date let's set it to the project start date
            if (!startDate) {
                task.setStartDateWithoutPropagation(taskStore.getProjectStartDate(), undefined !== task.getDuration());
            }
            // default duration is gonna be 1 duration unit (day by default)
            if (!endDate) {
                task.setDurationWithoutPropagation(1);
            }

            task.endEdit();
        }
    },


<span id='Gnt-data-DependencyStore-method-scheduleLinkedTasks'>    // Checks tasks linked by dependency if they are fully scheduled
</span>    // and fills their missing start/end/duration values otherwise.
    scheduleLinkedTasks : function (from, to) {
        // schedule predecessor (if required)
        this.scheduleTask(from);

        // if successor has no start date and `cascadeChanges` is disabled we'll try to
        // schedule it by alignByIncomingDependencies() call
        if (!to.getStartDate() &amp;&amp; !from.getTaskStore().cascadeChanges) {
            to.alignByIncomingDependencies();
        }

        // schedule successor (if required)
        this.scheduleTask(to);
    },


<span id='Gnt-data-DependencyStore-method-onDependencyAdd'>    onDependencyAdd : function (me, dependencies) {
</span>        // need to ignore the initial &quot;add&quot; events for data provided in the config
        if (this.ignoreInitial) return;

        for (var i = 0; i &lt; dependencies.length; i++) {
            var dependency  = dependencies[ i ];

            if (!this.isValidDependencyType(dependency.getType())) throw 'This dependency type is invalid. Check Gnt.data.DependencyStore#allowedDependencyTypes value';

            var from        = dependency.getSourceTask(),
                to          = dependency.getTargetTask();

            if (from &amp;&amp; to) {
                from.successors.push(dependency);
                to.predecessors.push(dependency);

                // ensure that tasks being linked are fully scheduled
                this.scheduleLinkedTasks(from, to);
            }
        }

        me.resetMethodsCache();
    },


<span id='Gnt-data-DependencyStore-method-onDependencyRemove'>    onDependencyRemove : function (me, dependencies, index, isMove) {
</span>        var taskStore       = this.getTaskStore();
        var tasksToAdjust   = [];

        // dependencies are already removed from the dependecies store and has no reference to it
        // so `getTaskStore` on the dependency instance won't work, need to provide `taskStore` manually
        Ext.Array.forEach(dependencies, function (dependency) {
            var from        = dependency.getSourceTask(taskStore),
                to          = dependency.getTargetTask(taskStore);

            if (from) {
                Ext.Array.remove(from.successors, dependency);
            }

            if (to) {
                Ext.Array.remove(to.predecessors, dependency);

                if (!to.isManuallyScheduled()) {
                    tasksToAdjust.push(to);
                }
            }
        });

        me.resetMethodsCache();

        // Readjust any target tasks
        Ext.Array.forEach(tasksToAdjust, function(task) { task.adjustToCalendarWithoutPropagation(); });
    },


<span id='Gnt-data-DependencyStore-method-onDependencyUpdate'>    onDependencyUpdate : function (me, dependency, operation) {
</span>        if (operation != Ext.data.Model.COMMIT) {
            var taskStore       = this.getTaskStore();
            var previous        = dependency.previous;

            var newFromTask     = dependency.getSourceTask();
            var newToTask       = dependency.getTargetTask();
            var fromChanged     = previous &amp;&amp; dependency.fromField in previous;
            var toChanged       = previous &amp;&amp; dependency.toField in previous;

            if (fromChanged) {
                var oldFromTask = taskStore.getModelById(previous[ dependency.fromField ]);

                oldFromTask &amp;&amp; Ext.Array.remove(oldFromTask.successors, dependency);

                if (newFromTask &amp;&amp; Ext.Array.indexOf(newFromTask.successors, dependency) &lt; 0) {
                    newFromTask.successors.push(dependency);
                }
            }

            if (toChanged) {
                var oldToTask   = taskStore.getModelById(previous[ dependency.toField ]);
                // remove from old array
                oldToTask &amp;&amp; Ext.Array.remove(oldToTask.predecessors, dependency);

                if (newToTask &amp;&amp; Ext.Array.indexOf(newToTask.predecessors, dependency) &lt; 0) {
                    newToTask.predecessors.push(dependency);
                }
            }

            if ((fromChanged || toChanged) &amp;&amp; newFromTask &amp;&amp; newToTask) {
                this.scheduleLinkedTasks(newFromTask, newToTask);
            }

            this.resetMethodsCache();
        }
    },


<span id='Gnt-data-DependencyStore-method-onDependencyStoreClear'>    onDependencyStoreClear : function (me) {
</span>        var taskStore       = me.getTaskStore();

        taskStore &amp;&amp; taskStore.fillTasksWithDepInfo();
    },

<span id='Gnt-data-DependencyStore-method-getDependenciesForTask'>    /**
</span>     * Returns all dependencies of for a certain task (both incoming and outgoing)
     *
     * @param {Gnt.model.Task} task
     *
     * @return {Gnt.model.Dependency[]}
     */
    getDependenciesForTask : function (task) {
        return task.successors.concat(task.predecessors);
    },

<span id='Gnt-data-DependencyStore-method-getIncomingDependenciesForTask'>    /**
</span>     * Returns all incoming dependencies of the given task
     *
     * @param {Gnt.model.Task} task
     *
     * @return {Gnt.model.Dependency[]}
     */
    getIncomingDependenciesForTask: function (task, doNotClone) {
        return doNotClone ? task.predecessors : task.predecessors.slice();
    },


<span id='Gnt-data-DependencyStore-method-getOutgoingDependenciesForTask'>    /**
</span>     * Returns all outcoming dependencies of a task
     *
     * @param {Gnt.model.Task} task
     *
     * @return {Gnt.model.Dependency[]}
     */
    getOutgoingDependenciesForTask: function (task, doNotClone) {
        return doNotClone ? task.successors : task.successors.slice();
    },

<span id='Gnt-data-DependencyStore-method-getKeyByDeps'>    // @private
</span>    // Serializes array of dependencies. Used during cache key calculation.
    getKeyByDeps : function (dependencies, fromField, toField) {
        if (!dependencies || !dependencies.length) return '';

        var key     = '';

        for (var i = 0, l = dependencies.length; i &lt; l; i++) {
            var dep     = dependencies[i];

            key += (dep.getSourceId &amp;&amp; dep.getSourceId() || dep[fromField]) + ':' +
                (dep.getTargetId &amp;&amp; dep.getTargetId() || dep[toField]) + ',';
        }

        return key;
    },


<span id='Gnt-data-DependencyStore-method-buildCacheKey'>    buildCacheKey : function (sourceId, targetId, ignoreDepRecords, addDepRecords, context) {
</span>        var fromField       = context.fromField || (context.fromField = this.model.prototype.fromField),
            toField         = context.toField || (context.toField = this.model.prototype.toField),
            ignoreDepKey    = context.ignoreDepKey,
            addDepKey       = context.addDepKey;

        // let's preserve key part calculated by ignoreDepRecords and addDepRecords since they will not change
        if (!context.hasOwnProperty('ignoreDepKey')) {
            context.ignoreDepKey    = ignoreDepKey    = ignoreDepRecords &amp;&amp; this.getKeyByDeps(ignoreDepRecords, fromField, toField) || '';
            context.addDepKey       = addDepKey       = addDepRecords &amp;&amp; this.getKeyByDeps(addDepRecords, fromField, toField) || '';
        }

        // calculate cache key for provided arguments
        return sourceId + '-' + targetId + '-' + ignoreDepKey + '-' + addDepKey;
    },


<span id='Gnt-data-DependencyStore-method-hasTransitiveDependency'>    /**
</span>     * Returns `true` if there is a dependency (either direct or &quot;transitive&quot;) between tasks
     * with `sourceId` and `targetId`
     *
     * @param {String} sourceId
     * @param {String} targetId
     * @param {Gnt.model.Dependency[]} [ignoreDepRecords] If provided, dependencies in this array will be ignored during transitivity search.
     * @param {Gnt.model.Dependency[]/Object[]} [addDepRecords] If provided, search will be done supposing that specified records exist in the dependency store.
     *
     * @return {Boolean}
     */
    hasTransitiveDependency: function (sourceId, targetId, ignoreDepRecords, addDepRecords, context) {
        context             = context || { visitedTasks : {}};

        // calculate cache key for provided arguments
        var cacheKey        = this.buildCacheKey(sourceId, targetId, ignoreDepRecords, addDepRecords, context);

        var visitedTasks    = context.visitedTasks,
            extraSuccessors = context.extraSuccessors;

        if (this.isCachedResultAvailable('hasTransitiveDependency', cacheKey)) {
            return this.methodsCache.hasTransitiveDependency[ cacheKey ];
        }

        var me              = this,
            fromField       = context.fromField,
            toField         = context.toField,
            sourceTask      = this.getTaskById(sourceId),
            i, l;

        // protection from cycles
        if (visitedTasks[ sourceId ]) return false;

        visitedTasks[ sourceId ] = true;

        if (sourceTask) {
            // if list of dependencies to be created is provided let's
            // organize it as a hash containing successors list by task ids
            if (addDepRecords &amp;&amp; !extraSuccessors) {
                extraSuccessors = context.extraSuccessors     = {};

                for (i = 0, l = addDepRecords.length; i &lt; l; i++) {
                    var dep     = addDepRecords[i];
                    var from    = dep.getSourceId &amp;&amp; dep.getSourceId() || dep[fromField];

                    extraSuccessors[from] = extraSuccessors[from] || [];
                    extraSuccessors[from].push(dep);
                }
            }

            var dependency,
                successors      = sourceTask.successors;

            // add successors to be added to existing successors
            if (extraSuccessors &amp;&amp; extraSuccessors[sourceId]) successors = successors.concat(extraSuccessors[sourceId]);

            for (i = 0, l = successors.length; i &lt; l; i++) {
                dependency  = successors[ i ];
                var target  = dependency.getTargetId &amp;&amp; dependency.getTargetId() || dependency[toField];

                if ((!ignoreDepRecords || Ext.Array.indexOf(ignoreDepRecords, dependency) == -1) &amp;&amp;
                    (target === targetId || me.hasTransitiveDependency(target, targetId, ignoreDepRecords, addDepRecords, context))) {
                    return this.setCachedResult('hasTransitiveDependency', cacheKey, true);
                }
            }
        }

        return this.setCachedResult('hasTransitiveDependency', cacheKey, false);
    },


<span id='Gnt-data-DependencyStore-method-successorsHaveTransitiveDependency'>    successorsHaveTransitiveDependency : function (sourceId, targetId, ignoreDepRecords, addDepRecords, context) {
</span>        context             = context || {};

        // calculate cache key for provided arguments
        var cacheKey        = this.buildCacheKey(sourceId, targetId, ignoreDepRecords, addDepRecords, context);

        var task            = targetId instanceof Gnt.model.Task ? targetId : this.getTaskById(targetId);

        if (this.isCachedResultAvailable('successorsHaveTransitiveDependency', cacheKey)) {
            return this.methodsCache.successorsHaveTransitiveDependency[ cacheKey ];
        }

        for (var i = 0, l = task.successors.length; i &lt; l; i++) {
            var toId    = task.successors[i].getTargetId();

            if (this.hasTransitiveDependency(sourceId, toId, ignoreDepRecords, addDepRecords) ||
                this.predecessorsHaveTransitiveDependency(sourceId, toId, ignoreDepRecords, addDepRecords) ||
                this.successorsHaveTransitiveDependency(sourceId, toId, ignoreDepRecords, addDepRecords, context))
                    return this.setCachedResult('successorsHaveTransitiveDependency', cacheKey, true);
        }

        return this.setCachedResult('successorsHaveTransitiveDependency', cacheKey, false);
    },


<span id='Gnt-data-DependencyStore-method-predecessorsHaveTransitiveDependency'>    predecessorsHaveTransitiveDependency : function (sourceId, targetId, ignoreDepRecords, addDepRecords, context) {
</span>        context             = context || {};

        // calculate cache key for provided arguments
        var cacheKey        = this.buildCacheKey(sourceId, targetId, ignoreDepRecords, addDepRecords, context);

        var task            = sourceId instanceof Gnt.model.Task ? sourceId : this.getTaskById(sourceId);

        if (this.isCachedResultAvailable('predecessorsHaveTransitiveDependency', cacheKey)) {
            return this.methodsCache.predecessorsHaveTransitiveDependency[ cacheKey ];
        }

        for (var i = 0, l = task.predecessors.length; i &lt; l; i++) {
            var fromId    = task.predecessors[i].getSourceId();

            if (this.hasTransitiveDependency(fromId, targetId, ignoreDepRecords, addDepRecords) ||
                this.successorsHaveTransitiveDependency(fromId, targetId, ignoreDepRecords, addDepRecords) ||
                this.predecessorsHaveTransitiveDependency(fromId, targetId, ignoreDepRecords, addDepRecords, context))
                    return this.setCachedResult('predecessorsHaveTransitiveDependency', cacheKey, true);
        }

        return this.setCachedResult('predecessorsHaveTransitiveDependency', cacheKey, false);
    },


<span id='Gnt-data-DependencyStore-method-isPartOfTransitiveDependency'>    isPartOfTransitiveDependency : function (sourceId, targetId, ignoreDepRecords, addDepRecords) {
</span>        var task    = sourceId instanceof Gnt.model.Task ? sourceId : this.getTaskById(sourceId);

        if (!task.predecessors.length &amp;&amp; !task.successors.length) return false;

        if (task.predecessors.length) {
            return this.predecessorsHaveTransitiveDependency.apply(this, arguments);
        } else {
            return this.successorsHaveTransitiveDependency.apply(this, arguments);
        }
    },


<span id='Gnt-data-DependencyStore-method-getCycle'>    getCycle : function (context) {
</span>        context             = context || {};

        Ext.applyIf(context, {
            ignoreTasks     : {},
            visitedTasks    : {},
            path            : [],
            task            : this.getAt(0).getSourceTask()
        });

        var visitedTasks    = context.visitedTasks,
            ignoreTasks     = context.ignoreTasks,
            path            = context.path,
            task            = context.task,
            taskId          = task.getId();

        if (ignoreTasks[taskId]) return;

        path.push(task);

        if (visitedTasks[taskId]) return path;

        visitedTasks[taskId]    = true;

        var successors          = task.successors;

        for (var i = 0, l = successors.length; i &lt; l; i++) {
            context.task    = successors[ i ].getTargetTask();

            var cycle       = this.getCycle(context);

            if (cycle) return cycle;
        }

        path.pop();
        delete visitedTasks[taskId];
    },


<span id='Gnt-data-DependencyStore-method-getCycles'>    // TODO improve so it can detect all cycles
</span>    getCycles : function () {
        var me          = this,
            result      = [],
            ignoreTasks = {};

        this.each(function (dep) {
            var path    = me.getCycle({ task : dep.getSourceTask(), ignoreTasks : ignoreTasks });

            if (path) {
                for (var i = 0, l = path.length; i &lt; l; i++) {
                    ignoreTasks[path[i]]    = true;
                }
                result.push(path);
            }
        });

        return result;
    },


<span id='Gnt-data-DependencyStore-method-resetMethodsCache'>    resetMethodsCache : function () {
</span>        this.methodsCache   = {};
    },


<span id='Gnt-data-DependencyStore-method-isCachedResultAvailable'>    isCachedResultAvailable : function (method, key) {
</span>        return this.methodsCache[method] &amp;&amp; this.methodsCache[method].hasOwnProperty(key);
    },


<span id='Gnt-data-DependencyStore-method-getCachedResult'>    getCachedResult : function (method, key) {
</span>        return this.methodsCache[ method ][ key ];
    },


<span id='Gnt-data-DependencyStore-method-setCachedResult'>    setCachedResult : function (method, key, value) {
</span>        this.methodsCache[method]       = this.methodsCache[method] || {};
        this.methodsCache[method][key]  = value;

        return value;
    },

<span id='Gnt-data-DependencyStore-method-getGroupTopTasks'>    //@private
</span>    getGroupTopTasks : function(sourceGroup, targetGroup) {
        var sourceGroupLength    = sourceGroup.length,
            targetGroupLength    = targetGroup.length,
            i                    = sourceGroupLength,
            j                    = targetGroupLength,
            sourceTopParent, targetTopParent;

        do {
            sourceTopParent     = sourceGroup[i];
            targetTopParent     = targetGroup[j];
            i--;
            j--;
        } while (sourceTopParent == targetTopParent &amp;&amp; i &gt;= 0 &amp;&amp; j&gt;=0);

        return [sourceTopParent, targetTopParent];
    },

<span id='Gnt-data-DependencyStore-method-groupsHasTransitiveDependency'>    groupsHasTransitiveDependency : function (sourceId, targetId, ignoreDepRecords, addDepRecords, context) {
</span>        var ctx     = context || {
            targets         : null,
            visitedTasks    : {}
        };

        var root                = this.getTaskStore().getRootNode(),
            result              = false,
            me                  = this,
            source              = this.getTaskById(sourceId),
            target              = this.getTaskById(targetId),
            visitedTasks        = ctx.visitedTasks,
            targets             = ctx.targets;

        if (!ctx.targetGroup) {
            ctx.targetGroup     = target.getTopParent(true);
        }

        var fromField       = ctx.fromField || (ctx.fromField = this.model.prototype.fromField),
            toField         = ctx.toField || (ctx.toField = this.model.prototype.toField),
            ignoreDepKey    = ctx.ignoreDepKey,
            addDepKey       = ctx.addDepKey;

        // get groups top elements based on their intersection
        var groups          = this.getGroupTopTasks(source.getTopParent(true), ctx.targetGroup),
            sourceTopParent = groups[0],
            targetTopParent = groups[1];

        if (sourceTopParent === source &amp;&amp; targetTopParent === target &amp;&amp; source.isLeaf() &amp;&amp; target.isLeaf()) {
            return this.hasTransitiveDependency(sourceId, targetId, ignoreDepRecords);
        }

        // let's preserve key part calculated by ignoreDepRecords and addDepRecords since they will not change
        if (!ctx.hasOwnProperty('ignoreDepKey')) {
            ctx.ignoreDepKey    = ignoreDepKey    = ignoreDepRecords &amp;&amp; this.getKeyByDeps(ignoreDepRecords, fromField, toField) || '';
            ctx.addDepKey       = addDepKey       = addDepRecords &amp;&amp; this.getKeyByDeps(addDepRecords, fromField, toField) || '';
        }

        // calculate cache key for provided arguments
        var cacheKey        = sourceTopParent.getId() + '-' + targetTopParent.getId() + '-' + ignoreDepKey + '-' + addDepKey;

        if (this.isCachedResultAvailable('groupsHasTransitiveDependency', cacheKey)) {
            return this.methodsCache.groupsHasTransitiveDependency[cacheKey];
        }

        // if top target element has changed for this source group
        // then we need to regather &quot;targets&quot; hash
        if (targetTopParent !== ctx.targetTopParent) {
            ctx.targetTopParent     = targetTopParent;
            targets                 = ctx.targets = {};
            // collect children Ids into targets hash
            targetTopParent.cascadeBy(function (task) { targets[ task.getId() ] = true; });
        }

        var extraSuccessors     = ctx.extraSuccessors;

        // if list of dependencies to be created is provided let's
        // organize it as a hash containing successors list by task ids
        if (addDepRecords &amp;&amp; !extraSuccessors) {
            extraSuccessors = ctx.extraSuccessors     = {};

            for (var i = 0, l = addDepRecords.length; i &lt; l; i++) {
                var dep     = addDepRecords[i];
                var from    = dep.getSourceId &amp;&amp; dep.getSourceId() || dep[fromField];

                extraSuccessors[from] = extraSuccessors[from] || [];
                extraSuccessors[from].push(dep);
            }
        }

        // for each source group task we check if any of its succeeding task is in &quot;targets&quot; hash
        sourceTopParent.cascadeBy(function (task) {
            if (task !== root) {
                var taskId      = task.getId();

                // data cycles protection
                if (visitedTasks[ taskId ]) return false;

                visitedTasks[ taskId ]  = true;

                var successors          = task.successors;

                // add successors to be added to existing successors
                if (extraSuccessors &amp;&amp; extraSuccessors[taskId]) successors = successors.concat(extraSuccessors[taskId]);

                for (var i = 0, l = successors.length; i &lt; l; i++) {
                    var dependency  = successors[i],
                        toId        = dependency.getTargetId &amp;&amp; dependency.getTargetId() || dependency[toField];
                    // if succeeding task is not in ignore list
                    // and it's in &quot;targets&quot; then we found transitivity
                    // otherwise we go deeper
                    if ((!ignoreDepRecords || Ext.Array.indexOf(ignoreDepRecords, dependency) == -1) &amp;&amp;
                        (targets[toId] || me.groupsHasTransitiveDependency(toId, targetId, ignoreDepRecords, addDepRecords, ctx))) {
                        result  = true;
                        return false;
                    }
                }
            }
        });

        // update cache
        return this.setCachedResult('groupsHasTransitiveDependency', cacheKey, result);
    },


<span id='Gnt-data-DependencyStore-method-getDependencyError'>    /**
</span>     * Validates a provided dependency and returns a corresponding error code or zero if no error was detected.
     * This method can validate either an existing {@link Gnt.model.Dependency} instance or a proposed (about to be created) link
     * that can be specified as source and target task identifiers plus the dependency type.
     *
     * If you subclass this class, you can provide your own version of this method.
     * Please note that this method is supposed to return a negative integer error code so
     * ensure that you choose some unused values for any new kind of validation.
     * Don't forget to call the parent implementation if you also want to check for cyclic dependencies etc.
     *
     * These scenarios are considered invalid:
     *
     * - a task linking to itself
     * - a dependency between a child and one of its parents
     * - transitive dependencies (this check is done only when {@link #transitiveDependencyValidation} is set to `True`), e.g. if A -&gt; B, B -&gt; C, then A -&gt; C is not valid, or if A -&gt; B, A -&gt; C, then B -&gt; C is not valid
     * - cyclic dependencies, e.g. if A -&gt; B, B -&gt; C, then C -&gt; A is not valid
     *
     * **Note:** This method behavior depends on {@link #transitiveDependencyValidation} and {@link #strictDependencyValidation} option.
     * The first config enables so called _transitivity_ validation. And when {@link #strictDependencyValidation} is turned on,
     * the system tries to detect cycles (and transitivity if {@link #transitiveDependencyValidation} enabled) cases between groups of tasks.
     *
     * The method can be used either by providing a dependency as the first argument (then `toId` and `type` should be omitted):
     *
     *      // checking dependency record
     *      switch (dependencyStore.getDependencyError(dependency)) {
     *          case -3: case -8: case -5:
     *              alert('This dependency builds duplicating transitivity');
     *              break;
     *          case -4: case -7:
     *              alert('This is a cyclic dependency');
     *              break;
     *          ...
     *      }
     *
     * or by providing identifiers of the source and target tasks as well as the type of the dependency (if `type` is not provided it defaults to End-To-Start):
     *
     *      // check if 11 --&gt; 15 dependency is between parent &amp; child
     *      if (dependencyStore.getDependencyError(11, 15) == -9) {
     *          alert('This is a dependency between parent and its child');
     *      }
     *
     * @param {Gnt.model.Dependency/Mixed} dependencyOrFromId Either a dependency or the source task id
     * @param {Mixed} [toId] The target task id. Should be omitted if `dependencyOrFromId` is {@link Gnt.model.Dependency} instance.
     * @param {Number} [type] The type of the dependency. Should be omitted if `dependencyOrFromId` is {@link Gnt.model.Dependency} instance.
     * @param {Gnt.model.Dependency[]/Object[]} [dependenciesToAdd] If provided, validation will be done assuming that the specified records exist in the dependency store.
     * @param {Gnt.model.Dependency[]} [dependenciesToRemove]  If provided, validation will be done assuming that the specified records DO NOT exist in the dependency store.
     * @return {Number} Returns zero if dependency is valid.
     * Full list of possible values is:
     *
     *  - `0`  dependency is valid
     *  - `-1`  other error (wrong input data provided: empty source/target Id(s) or source Id equals target Id)
     *  - `-2`  source (or target) task is not found
     *  - `-3`  transitive dependency (returned only when {@link #transitiveDependencyValidation} is `True`)
     *  - `-4`  cyclic dependency
     *  - `-5`  transitive dependency (dependency being validated is part of larger transitive route) (returned only when {@link #transitiveDependencyValidation} is `True`)
     *  - `-7`  cyclic dependency between groups
     *  - `-8`  transitive dependency between groups (returned only when {@link #transitiveDependencyValidation} is `True`)
     *  - `-9`  dependency between parent and child
     *  - `-10` wrong dependency type
     *  - `-11` dependencies to/from parent tasks not allowed
     *  - `-12` dependencies to projects not allowed
     *  - `-13` dependencies to other project tasks not allowed
     */
    getDependencyError : function (dependencyOrFromId, toId, type, dependenciesToAdd, dependenciesToRemove, calledFromThisDepModel) {
        // `calledFromThisModel` is used when called from `isValid` method of depedency model
        var fromId, fromTask, toTask;

        var modelInput      = dependencyOrFromId instanceof Gnt.model.Dependency;

        // Normalize input
        if (modelInput) {
            fromId                  = dependencyOrFromId.getSourceId();
            fromTask                = this.getTaskById(fromId);

            // if dependency provided then `toId` and `type` arguments can be skipped
            dependenciesToAdd       = toId;
            dependenciesToRemove    = type;

            // if dependency being validated presented in dependenciesToAdd list
            if (dependenciesToAdd &amp;&amp; Ext.Array.contains(dependenciesToAdd, dependencyOrFromId)) {
                // make list copy
                dependenciesToAdd   = Ext.Array.slice(dependenciesToAdd, 0);
                // and remove dependency from it
                Ext.Array.remove(dependenciesToAdd, dependencyOrFromId);
            }

            type                    = dependencyOrFromId.getType();
            toId                    = dependencyOrFromId.getTargetId();
            toTask                  = this.getTaskById(toId);

            // if we've been called with dependencies model as 1st arg (modelInput) and that dependency
            // is already in the dep store, this case is identical to called &quot;isValid&quot; method on the dependency record
            if (dependencyOrFromId.joined &amp;&amp; dependencyOrFromId.joined.length) calledFromThisDepModel = dependencyOrFromId;
        } else {
            fromId          = dependencyOrFromId;
            fromTask        = this.getTaskById(fromId);
            toTask          = this.getTaskById(toId);

            if (type === undefined) {
                // get default dependency type from the dependency class
                var defaultType = this.model.getField(this.model.prototype.typeField).defaultValue;
                type            = defaultType !== undefined ? defaultType : this.model.Type.EndToStart;
            }
        }

        if (!calledFromThisDepModel &amp;&amp; modelInput &amp;&amp; !dependencyOrFromId.isValid()) {
            return -1;
        } else if (!fromId || !toId || fromId == toId) {
            return -1;
        }

        // Both tasks need to exist for the link to make sense
        if (!fromTask || !toTask) return -2;

        // check dependency type
        if (!this.isValidDependencyType(type)) return -10;

        // Also, not allowed to setup a link between a parent and its child
        if (fromTask.contains(toTask) || toTask.contains(fromTask)) return -9;

        var depsToIgnore;
        if (dependenciesToRemove || calledFromThisDepModel) {
            depsToIgnore    = [];
            // ignore dependency itself during transitivities/cycles search
            if (calledFromThisDepModel) depsToIgnore.push(calledFromThisDepModel);
            if (dependenciesToRemove) depsToIgnore    = depsToIgnore.concat(dependenciesToRemove);
        }

        // checking the presence of transitivity in forward direction (fromId -&gt; toId) - prevents actual transitivity
        if (this.transitiveDependencyValidation) {
            if (this.hasTransitiveDependency(fromId, toId, depsToIgnore, dependenciesToAdd)) return -3;
        } else {
            // check if tasks are already linked directly
            if (this.areTasksLinkedForward(fromId, toId, depsToIgnore, dependenciesToAdd)) return -3;
        }
        // checking the presence of transitivity in backward direction (toId -&gt; fromId) - prevents cycles
        if (this.hasTransitiveDependency(toId, fromId, depsToIgnore, dependenciesToAdd)) return -4;

        // checking the presence of transitivity between fromId-task and some of toId-task successors
        // or between some of fromId-task predecessors and toId-task
        // it detects cases when we have 1-&gt;2, 1-&gt;3 dependencies and validating 2-&gt;3 dependency
        // and when we have 2-&gt;3, 1-&gt;3 dependencies and validating 1-&gt;2 dependency
        if (this.transitiveDependencyValidation &amp;&amp; this.isPartOfTransitiveDependency(fromId, toId, depsToIgnore, dependenciesToAdd)) return -5;

        // if strict dependencies validation mode enabled
        if (this.strictDependencyValidation) {
            // let's check if there is an opposite relation between the tasks parent-child stacks (to prevent cycle)
            if (this.groupsHasTransitiveDependency(toId, fromId, depsToIgnore, dependenciesToAdd)) return -7;
            // also check if there is some other relation of the same direction (to prevent transitivity)
            if (this.transitiveDependencyValidation &amp;&amp; this.groupsHasTransitiveDependency(fromId, toId, depsToIgnore, dependenciesToAdd)) return -8;
        }

        if (!this.allowParentTaskDependencies &amp;&amp; (!fromTask.isLeaf() || !toTask.isLeaf())) return -11;

        // project record itself cannot be linked w/ a dependency
        if (toTask.isProject || fromTask.isProject) {
            return -12;
        }

        // children of a project are connectible depending on &quot;AllowDependencies&quot; flag
        var toProject   = toTask.getProject(),
            fromProject = fromTask.getProject();

        if (toProject != fromProject) {
            if (toProject &amp;&amp; !toProject.getAllowDependencies() || fromProject &amp;&amp; !fromProject.getAllowDependencies()) {
                return -13;
            }
        }

        return 0;
    },

<span id='Gnt-data-DependencyStore-method-isValidDependencyType'>    isValidDependencyType   : function (type) {
</span>        if (this.allowedDependencyTypes) {
            var result  = false,
                model   = this.model;

            Ext.each(this.allowedDependencyTypes, function (name) {
                if (model.Type[name] == type) {
                    result = true;

                    return false;
                }
            });

            return result;
        }

        return true;
    },

<span id='Gnt-data-DependencyStore-method-isValidDependency'>    /**
</span>     * Returns `true` if a dependency (or about to be created dependency) between two tasks is valid.
     *
     * **Please note,** If you subclass this class, that this method is just a wrapper over {@link #getDependencyError}
     * method so if you want to implement a custom validation please override {@link #getDependencyError}.
     * And don't forget to call the parent implementation if you also want the check for cyclic dependencies etc.
     *
     * These scenarios are considered invalid:
     *
     * - a task linking to itself
     * - a dependency between a child and one of its parents
     * - transitive dependencies, e.g. if A -&gt; B, B -&gt; C, then A -&gt; C is not valid, or if A -&gt; B, A -&gt; C, then B -&gt; C is not valid
     * - cyclic dependencies, e.g. if A -&gt; B, B -&gt; C, then C -&gt; A is not valid
     *
     * **Note:** This method behavior depends on {@link #strictDependencyValidation} option.
     * When {@link #strictDependencyValidation} is turned on the system tries to detect cycles and transitivity cases between _groups of tasks_.
     *
     * Method can be used either by providing dependency in first argument (and then `toId` and `type` **should** be omitted):
     *
     *      // validating dependency record
     *      if (!dependencyStore.isValidDependency(dependency)) ...
     *
     * or by providing identifiers of source and target tasks and type of dependency (here `type` can be omitted as well if no further arguments are required):
     *
     *      // if 11 --&gt; 15 dependency is valid
     *      if (dependencyStore.isValidDependency(11, 15)) {
     *          // let`s create it
     *          dependencyStore.add({ From: 11, To: 15 })
     *      }
     *
     * @param {Gnt.model.Dependency/Mixed} dependencyOrFromId Either a dependency or the source task id
     * @param {Mixed} [toId] The target task id. Should be omitted if `dependencyOrFromId` is {@link Gnt.model.Dependency} instance.
     * @param {Number} [type] The type of the dependency. Should be omitted if `dependencyOrFromId` is {@link Gnt.model.Dependency} instance.
     * @param {Gnt.model.Dependency[]/Object[]} [dependenciesToAdd] If provided, validation will be done supposing that specified records exist in the dependency store.
     * @param {Gnt.model.Dependency[]} [dependenciesToRemove]  If provided, validation will be done supposing that specified records DO NOT exist in the dependency store.
     * @return {Boolean}
     */
    isValidDependency : function (dependencyOrFromId, toId, type, dependenciesToAdd, dependenciesToRemove, calledFromThisDepModel) {
        return !this.getDependencyError(dependencyOrFromId, toId, type, dependenciesToAdd, dependenciesToRemove, calledFromThisDepModel);
    },


<span id='Gnt-data-DependencyStore-method-areTasksLinkedForward'>    /**
</span>     * Returns true if there is a direct forward dependency between the two tasks.
     * Please see also {@link #areTasksLinked} method to check both forward and backward directions.
     *
     * @param {Mixed/Gnt.model.Task} fromTask The id of source task
     * @param {Mixed/Gnt.model.Task} toTask The id of target task
     *
     * @return {Boolean}
     */
    areTasksLinkedForward : function (fromTaskOrId, toTaskOrId, dependenciesToRemove, dependenciesToAdd) {
        var from        = fromTaskOrId instanceof Gnt.model.Task ? fromTaskOrId : this.getTaskById(fromTaskOrId);
        var to          = toTaskOrId instanceof Gnt.model.Task ? toTaskOrId : this.getTaskById(toTaskOrId);

        if (!from || !to) return false;

        var model       = this.model.prototype,
            fromField   = model.fromField,
            toField     = model.toField;

        var cacheKey    = from.getId() + '-' + to.getId() + '-' +
            (this.getKeyByDeps(dependenciesToRemove, fromField, toField) || '') + '-' +
            (this.getKeyByDeps(dependenciesToAdd, fromField, toField) || '');

        if (this.isCachedResultAvailable('areTasksLinkedForward', cacheKey)) {
            return this.methodsCache.areTasksLinkedForward[ cacheKey ];
        }

        var successors      = from.successors,
            predecessors    = to.predecessors,
            dep, i, l;
        // loop over source task successors and check if some of them is presented in target tasks predecessors
        for (i = 0, l = successors.length; i &lt; l; i++) {
            dep             = successors[i];
            // ignore dependencies provided in dependenciesToRemove array
            if ((!dependenciesToRemove || !Ext.Array.contains(dependenciesToRemove, dep)) &amp;&amp; Ext.Array.contains(predecessors, dep))
                return this.setCachedResult('areTasksLinkedForward', cacheKey, true);
        }

        // if provided list of dependencies that we must consider as existing in the store
        if (dependenciesToAdd) {
            var sourceId, targetId;

            // let's loop over it and check if link between task is presented there
            for (i = 0, l = dependenciesToAdd.length; i &lt; l; i++) {
                dep         = dependenciesToAdd[i];
                sourceId    = dep.getSourceId &amp;&amp; dep.getSourceId() || dep[fromField];
                targetId    = dep.getTargetId &amp;&amp; dep.getTargetId() || dep[toField];

                if (sourceId == from.getId() &amp;&amp; targetId == to.getId())
                    return this.setCachedResult('areTasksLinkedForward', cacheKey, true);
            }
        }

        return this.setCachedResult('areTasksLinkedForward', cacheKey, false);
    },


<span id='Gnt-data-DependencyStore-method-areTasksLinked'>    /**
</span>     * Returns true if there is a direct dependency between the two tasks. The dependency can be forward (from 1st task to 2nd)
     * or backward (from 2nd to 1st).
     *
     * @param {Mixed/Gnt.model.Task} id1 The id of 1st task
     * @param {Mixed/Gnt.model.Task} id2 The id of 2nd task
     *
     * @return {Boolean}
     */
    areTasksLinked : function (fromTaskOrId, toTaskOrId) {
        var from        = fromTaskOrId instanceof Gnt.model.Task ? fromTaskOrId : this.getTaskById(fromTaskOrId);
        var to          = toTaskOrId instanceof Gnt.model.Task ? toTaskOrId : this.getTaskById(toTaskOrId);

        if (!from || !to) return false;

        var cacheKey    = from.getId() + '-' + to.getId();

        if (this.isCachedResultAvailable('areTasksLinked', cacheKey)) {
            return this.methodsCache.areTasksLinked[ cacheKey ];
        }

        return this.setCachedResult('areTasksLinked', cacheKey, this.areTasksLinkedForward(from, to) || this.areTasksLinkedForward(to, from));
    },

<span id='Gnt-data-DependencyStore-method-getByTaskIds'>    /**
</span>     * Returns dependency model instance linking tasks with given ids. The dependency can be forward (from 1st
     * task to 2nd) or backward (from 2nd to 1st).
     *
     * @param {String} id1 The id of 1st task
     * @param {String} id2 The id of 2nd task
     *
     * @return {Gnt.model.Dependency|undefined}
     */
    getByTaskIds: function (id1, id2) {
        var index = this.findBy(function (dependency) {

            var toId    = dependency.getTargetId(),
                fromId  = dependency.getSourceId();

            if ((fromId === id1 &amp;&amp; toId === id2) || (fromId === id2 &amp;&amp; toId === id1)) {
                return true;
            }
        });

        return this.getAt(index);
    },


<span id='Gnt-data-DependencyStore-method-getTaskById'>    getTaskById : function (id) {
</span>        var taskStore = this.getTaskStore();
        return taskStore &amp;&amp; taskStore.getModelById(id) || null;
    },


<span id='Gnt-data-DependencyStore-method-getSourceTask'>    /**
</span>     * Returns the source task of the dependency
     *
     * @param {Gnt.model.Dependency} dependency The dependency
     * @return {Gnt.model.Task} The source task of this dependency
     */
    getSourceTask : function(dependencyOrId) {
        var id = dependencyOrId instanceof Gnt.model.Dependency ? dependencyOrId.getSourceId() : dependencyOrId;
        return this.getTaskById(id);
    },

<span id='Gnt-data-DependencyStore-method-getTargetTask'>    /**
</span>     * Returns the target task of the dependency
     * @param {Gnt.model.Dependency} dependency The dependency
     * @return {Gnt.model.Task} The target task of this dependency
     */
    getTargetTask : function(dependencyOrId) {
        var id = dependencyOrId instanceof Gnt.model.Dependency ? dependencyOrId.getTargetId() : dependencyOrId;
        return this.getTaskById(id);
    },


<span id='Gnt-data-DependencyStore-method-getTaskStore'>    /**
</span>     * Returns the {@link Gnt.data.TaskStore} instance, to which this dependency store is attached.
     * @return {Gnt.data.TaskStore}
     */
    getTaskStore : function() {
        return this.taskStore;
    },

<span id='Gnt-data-DependencyStore-method-setTaskStore'>    /**
</span>     * Sets the associated task store instance.
     *
     * @param {Gnt.data.TaskStore} store
     */
    setTaskStore : function(store) {
        // TODO: add taskstorechange event firing
        this.taskStore = store;
    }
});
</pre>
</body>
</html>
