<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Gnt-view-Gantt'>/**
</span>
@class Gnt.view.Gantt
@extends Sch.view.TimelineGridView

A view of the gantt panel. Use the {@link Gnt.panel.Gantt#getSchedulingView} method to get its instance from gantt panel.

*/
Ext.define(&quot;Gnt.view.Gantt&quot;, {
    extend : &quot;Sch.view.TimelineGridView&quot;,

    alias : ['widget.ganttview'],

    requires : [
        'Ext.dd.ScrollManager',
        'Gnt.view.Dependency',
        'Gnt.model.Task',
        'Gnt.template.Task',
        'Gnt.template.ParentTask',
        'Gnt.template.Milestone',
        'Gnt.template.RollupTask',
        'Gnt.feature.TaskDragDrop',
        'Gnt.feature.ProgressBarResize',
        'Gnt.feature.TaskResize',
        'Sch.view.Horizontal'
    ],

    uses : [
        'Gnt.feature.LabelEditor',
        'Gnt.feature.DragCreator'
    ],

    mixins : [
        'Sch.mixin.FilterableTreeView'
    ],

<span id='Gnt-view-Gantt-property-_cmpCls'>    _cmpCls : 'sch-ganttview',
</span>
<span id='Gnt-view-Gantt-property-barMargin'>    barMargin : 4,
</span>
<span id='Gnt-view-Gantt-property-scheduledEventName'>    scheduledEventName : 'task',
</span>
<span id='Gnt-view-Gantt-property-trackOver'>    trackOver           : false,
</span><span id='Gnt-view-Gantt-property-toggleOnDblClick'>    toggleOnDblClick    : false,
</span>
<span id='Gnt-view-Gantt-property-eventSelector'>    // private
</span>    eventSelector : '.sch-gantt-item',

<span id='Gnt-view-Gantt-property-eventWrapSelector'>    eventWrapSelector : '.sch-event-wrap',
</span>

<span id='Gnt-view-Gantt-property-progressBarResizer'>    progressBarResizer  : null,
</span><span id='Gnt-view-Gantt-property-taskResizer'>    taskResizer         : null,
</span><span id='Gnt-view-Gantt-property-taskDragDrop'>    taskDragDrop        : null,
</span><span id='Gnt-view-Gantt-property-dragCreator'>    dragCreator         : null,
</span><span id='Gnt-view-Gantt-property-dependencyView'>    dependencyView      : null,
</span>
<span id='Gnt-view-Gantt-property-resizeConfig'>    resizeConfig            : null,
</span><span id='Gnt-view-Gantt-property-createConfig'>    createConfig            : null,
</span><span id='Gnt-view-Gantt-property-dragDropConfig'>    dragDropConfig          : null,
</span><span id='Gnt-view-Gantt-property-progressBarResizeConfig'>    progressBarResizeConfig : null,
</span>
<span id='Gnt-view-Gantt-cfg-dependencyViewConfig'>    /**
</span>     * @cfg {Object} dependencyViewConfig
     * A config object to apply to internal instance of the {@link Gnt.view.Dependency}. Inner properties like {@link Gnt.view.Dependency#dragZoneConfig} and {@link Gnt.view.Dependency#dropZoneConfig}
     * will be applied to the dependency drag- and dropzone instances respectively.
     */
    dependencyViewConfig    : null,

<span id='Gnt-view-Gantt-property-externalGetRowClass'>    externalGetRowClass     : null,
</span>
<span id='Gnt-view-Gantt-cfg-outsideLabelsGatherWidth'>    /**
</span>     * @cfg {Number} outsideLabelsGatherWidth Defines width of special zone outside (before and after) of visible area within which tasks will be still rendered into DOM.
     * This is used to render partially visible labels of invisible tasks bordering with visible area.
     *
     * Increase this value to see long labels, set to 0 if you want to hide labels of invisible tasks completely.
     */
    outsideLabelsGatherWidth : 200,

    // Task click-events --------------------------
<span id='Gnt-view-Gantt-event-taskclick'>    /**
</span>     * @event taskclick
     * Fires when a task is clicked
     *
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord The task record
     * @param {Ext.EventObject} e The event object
     */

<span id='Gnt-view-Gantt-event-taskdblclick'>    /**
</span>     * @event taskdblclick
     * Fires when a task is double clicked
     *
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord The task record
     * @param {Ext.EventObject} e The event object
     */

<span id='Gnt-view-Gantt-event-taskcontextmenu'>    /**
</span>     * @event taskcontextmenu
     * Fires when contextmenu is activated on a task
     *
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord The task record
     * @param {Ext.EventObject} e The event object
     */

    // Resizing events start --------------------------
<span id='Gnt-view-Gantt-event-beforetaskresize'>    /**
</span>     * @event beforetaskresize
     * Fires before a resize starts, return false to stop the execution
     *
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord The task about to be resized
     * @param {Ext.EventObject} e The event object
     */

<span id='Gnt-view-Gantt-event-taskresizestart'>    /**
</span>     * @event taskresizestart
     * Fires when resize starts
     *
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord The task about to be resized
     */

<span id='Gnt-view-Gantt-event-partialtaskresize'>    /**
</span>     * @event partialtaskresize
     * Fires during a resize operation and provides information about the current start and end of the resized event
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     *
     * @param {Gnt.model.Task} taskRecord The task being resized
     * @param {Date} startDate The start date of the task
     * @param {Date} endDate The end date of the task
     * @param {Ext.Element} element The element being resized
     */

<span id='Gnt-view-Gantt-event-aftertaskresize'>    /**
</span>     * @event aftertaskresize
     * Fires after a succesful resize operation
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord The task that has been resized
     */

    // Task progress bar resizing events start --------------------------
<span id='Gnt-view-Gantt-event-beforeprogressbarresize'>    /**
</span>     * @event beforeprogressbarresize
     * Fires before a progress bar resize starts, return false to stop the execution
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord The record about to be have its progress bar resized
     */

<span id='Gnt-view-Gantt-event-progressbarresizestart'>    /**
</span>     * @event progressbarresizestart
     * Fires when a progress bar resize starts
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord The record about to be have its progress bar resized
     */

<span id='Gnt-view-Gantt-event-afterprogressbarresize'>    /**
</span>     * @event afterprogressbarresize
     * Fires after a succesful progress bar resize operation
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord record The updated record
     */

    // Dnd events start --------------------------
<span id='Gnt-view-Gantt-event-beforetaskdrag'>    /**
</span>     * @event beforetaskdrag
     * Fires before a task drag drop is initiated, return false to cancel it
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord The task record that's about to be dragged
     * @param {Ext.EventObject} e The event object
     */

<span id='Gnt-view-Gantt-event-taskdragstart'>    /**
</span>     * @event taskdragstart
     * Fires when a dnd operation starts
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord The record being dragged
     */

<span id='Gnt-view-Gantt-event-beforetaskdropfinalize'>    /**
</span>     * @event beforetaskdropfinalize
     * Fires before a succesful drop operation is finalized. Return false to finalize the drop at a later time.
     * To finalize the operation, call the 'finalize' method available on the context object. Pass `true` to it to accept drop or false if you want to cancel it
     * NOTE: you should **always** call `finalize` method whether or not drop operation has been canceled
     * @param {Mixed} view The gantt view instance
     * @param {Object} dragContext An object containing 'record', 'start', 'finalize' properties.
     * @param {Ext.EventObject} e The event object
     */

<span id='Gnt-view-Gantt-event-beforetaskresizefinalize'>    /**
</span>     * @event beforetaskresizefinalize
     * Fires before a succesful resize operation is finalized. Return false to finalize the resize at a later time.
     * To finalize the operation, call the 'finalize' method available on the context object. Pass `true` to it to accept drop or false if you want to cancel it
     * NOTE: you should **always** call `finalize` method whether or not drop operation has been canceled
     * @param {Mixed} view The gantt view instance
     * @param {Object} resizeContext An object containing 'record', 'start', 'end', 'finalize' properties.
     * @param {Ext.EventObject} e The event object
     */

<span id='Gnt-view-Gantt-event-beforedragcreatefinalize'>    /**
</span>     * @event beforedragcreatefinalize
     * Fires before a succesful create operation is finalized. Return false to finalize creating at a later time.
     * To finalize the operation, call the 'finalize' method available on the context object. Pass `true` to it to accept drop or false if you want to cancel it
     * NOTE: you should **always** call `finalize` method whether or not drop operation has been canceled
     * @param {Mixed} view The gantt view instance
     * @param {Object} createContext An object containing 'record', 'start', 'end', 'finalize' properties.
     * @param {Ext.EventObject} e The event object
     */

<span id='Gnt-view-Gantt-event-taskdrop'>    /**
</span>     * @event taskdrop
     * Fires after a succesful drag and drop operation
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord The dropped record
     */

<span id='Gnt-view-Gantt-event-aftertaskdrop'>    /**
</span>     * @event aftertaskdrop
     * Fires after a drag and drop operation, regardless if the drop valid or invalid
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     */

    // Label editors events --------------------------
<span id='Gnt-view-Gantt-event-labeledit_beforestartedit'>    /**
</span>     * @event labeledit_beforestartedit
     * Fires before editing is started for a field
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord The task record
     */

<span id='Gnt-view-Gantt-event-labeledit_beforecomplete'>    /**
</span>     * @event labeledit_beforecomplete
     * Fires after a change has been made to a label field, but before the change is reflected in the underlying field.
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Mixed} value The current field value
     * @param {Mixed} startValue The original field value
     * @param {Gnt.model.Task} taskRecord The affected record
     */

<span id='Gnt-view-Gantt-event-labeledit_complete'>    /**
</span>     * @event labeledit_complete
     * Fires after editing is complete and any changed value has been written to the underlying field.
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Mixed} value The current field value
     * @param {Mixed} startValue The original field value
     * @param {Gnt.model.Task} taskRecord The affected record
     */

    // Dependencies events--------------------------
<span id='Gnt-view-Gantt-event-beforedependencydrag'>    /**
</span>     * @event beforedependencydrag
     * Fires before a dependency drag operation starts (from a &quot;task terminal&quot;). Return false to prevent this operation from starting.
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord The source task record
     */

<span id='Gnt-view-Gantt-event-dependencydragstart'>    /**
</span>     * @event dependencydragstart
     * Fires when a dependency drag operation starts
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     */

<span id='Gnt-view-Gantt-event-dependencydrop'>    /**
</span>     * @event dependencydrop
     * Fires when a dependency drag drop operation has completed successfully and a new dependency has been created.
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} fromRecord The source task record
     * @param {Gnt.model.Task} toRecord The destination task record
     * @param {Number} type The dependency type
     */

<span id='Gnt-view-Gantt-event-afterdependencydragdrop'>    /**
</span>     * @event afterdependencydragdrop
     * Always fires after a dependency drag-drop operation
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     */

    // Drag create events start --------------------------
<span id='Gnt-view-Gantt-event-beforedragcreate'>    /**
</span>     * @event beforedragcreate
     * Fires before a drag create operation starts, return false to prevent the operation
     * @param {Gnt.view.Gantt} gantt The gantt view
     * @param {Gnt.model.Task} task The task record being updated
     * @param {Date} date The date of the drag start point
     * @param {Ext.EventObject} e The event object
     */

<span id='Gnt-view-Gantt-event-dragcreatestart'>    /**
</span>     * @event dragcreatestart
     * Fires before a drag starts, return false to stop the operation
     * @param {Gnt.view.Gantt} view The gantt view
     */

<span id='Gnt-view-Gantt-event-dragcreateend'>    /**
</span>     * @event dragcreateend
     * Fires after a successful drag-create operation
     * @param {Gnt.view.Gantt} view The gantt view
     * @param {Gnt.model.Task} task The updated task record
     * @param {Ext.EventObject} e The event object
     */

<span id='Gnt-view-Gantt-event-afterdragcreate'>    /**
</span>     * @event afterdragcreate
     * Always fires after a drag-create operation
     * @param {Gnt.view.Gantt} view The gantt view
     */
    // Drag create events end --------------------------


<span id='Gnt-view-Gantt-event-scheduleclick'>    /**
</span>     * @event scheduleclick
     * Fires after a click on the schedule area
     * @param {Gnt.view.Gantt} ganttView The gantt view object
     * @param {Date} clickedDate The clicked date
     * @param {Number} rowIndex The row index
     * @param {Ext.EventObject} e The event object
     */

<span id='Gnt-view-Gantt-event-scheduledblclick'>    /**
</span>     * @event scheduledblclick
     * Fires after a doubleclick on the schedule area
     * @param {Gnt.view.Gantt} ganttView The gantt view object
     * @param {Date} clickedDate The clicked date
     * @param {Number} rowIndex The row index
     * @param {Ext.EventObject} e The event object
     */

<span id='Gnt-view-Gantt-event-schedulecontextmenu'>    /**
</span>     * @event schedulecontextmenu
     * Fires after a context menu click on the schedule area
     * @param {Gnt.view.Gantt} ganttView The gantt view object
     * @param {Date} clickedDate The clicked date
     * @param {Number} rowIndex The row index
     * @param {Ext.EventObject} e The event object
     */

    constructor : function (config) {
        config = config || {};

        if (config) {
            this.externalGetRowClass = config.getRowClass;

            delete config.getRowClass;
        }

        this.callParent(arguments);

        this.on('boxready', this.onMyBoxReady, this);
        this.initTreeFiltering();
    },

<span id='Gnt-view-Gantt-method-onBeforeIndentationChange'>    onBeforeIndentationChange   : function () {
</span>        var position = this.getNavigationModel().getPosition();
        if (position &amp;&amp; position.record) {
            this._lastNavigatedRecord = position.record;
        }
    },

<span id='Gnt-view-Gantt-method-onIndentationChange'>    onIndentationChange    : function () {
</span>        this._lastNavigatedRecord &amp;&amp; this.getNavigationModel().setPosition(this._lastNavigatedRecord);
        delete this._lastNavigatedRecord;
    },

<span id='Gnt-view-Gantt-method-onRender'>    onRender : function () {
</span>        this.addCls('sch-ganttview-touch-only');

        // 213_indent
        // save navigation position during indenting
        this.mon(this.getTaskStore(), {
            beforeindentationchange: this.onBeforeIndentationChange,
            indentationchange: this.onIndentationChange,
            scope: this
        });

        this.configureLabels();
        this.setupGanttEvents();
        this.setupTemplates();
        this.callParent(arguments);

        // For monitors with both touch and mouse: If there is a mouse attached, remove the touch-specific CSS
        // https://www.assembla.com/spaces/bryntum/tickets/1922#/activity/ticket:
        Ext.getBody().on('mousemove', function() {
            this.removeCls('sch-ganttview-touch-only');
        }, this, { single : true});
    },

<span id='Gnt-view-Gantt-method-onMyBoxReady'>    onMyBoxReady : function() {
</span>        if (Ext.supports.Touch &amp;&amp; this.getNodeContainer()) {
            // Need to move the dependency container to the right place in the DOM to get it synced when
            // the virtual scroller is scrolling
            this.getDependencyView().getDependencyCanvas().insertBefore(this.getNodeContainer());
        }
    },

<span id='Gnt-view-Gantt-method-getDependencyStore'>    /**
</span>     * Returns the associated dependency store
     * @return {Gnt.data.TaskStore}
     */
    getDependencyStore : function () {
        return this.dependencyStore;
    },


<span id='Gnt-view-Gantt-method-configureFeatures'>    configureFeatures : function () {
</span>        if (this.enableProgressBarResize !== false) {
            this.progressBarResizer = Ext.create(&quot;Gnt.feature.ProgressBarResize&quot;, Ext.apply({
                ganttView: this
            }, this.progressBarResizeConfig || {}));

            this.on({
                beforeprogressbarresize : this.onBeforeTaskProgressBarResize,
                progressbarresizestart  : this.onTaskProgressBarResizeStart,
                afterprogressbarresize  : this.onTaskProgressBarResizeEnd,
                scope                   : this
            });
        }

        if (this.resizeHandles !== 'none') {

            this.taskResizer = Ext.create(&quot;Gnt.feature.TaskResize&quot;, Ext.apply({
                ganttView           : this,
                validatorFn         : this.resizeValidatorFn || Ext.emptyFn,
                validatorFnScope    : this
            }, this.resizeConfig || {}));

            this.on({
                beforedragcreate    : this.onBeforeDragCreate,
                beforetaskresize    : this.onBeforeTaskResize,
                taskresizestart     : this.onTaskResizeStart,
                aftertaskresize     : this.onTaskResizeEnd,
                scope: this
            });
        }

        if (this.enableTaskDragDrop) {
            // Seems we cannot use the gantt view el for the drag zone, it crashes IE9 in some cases.
            // See https://www.assembla.com/spaces/bryntum/tickets/716

            this.taskDragDrop = Ext.create(&quot;Gnt.feature.TaskDragDrop&quot;, this.ownerCt.el, Ext.apply({
                gantt               : this,
                validatorFn         : this.dndValidatorFn || Ext.emptyFn,
                validatorFnScope    : this
            }, this.dragDropConfig));

            this.on({
                beforetaskdrag  : this.onBeforeTaskDrag,
                taskdragstart   : this.onDragDropStart,
                aftertaskdrop   : this.onDragDropEnd,
                scope: this
            });
        }

        if (this.enableDragCreation) {
            this.dragCreator = Ext.create(&quot;Gnt.feature.DragCreator&quot;, Ext.apply({
                ganttView           : this,
                validatorFn         : this.createValidatorFn || Ext.emptyFn,
                validatorFnScope    : this
            }, this.createConfig));
        }
    },

<span id='Gnt-view-Gantt-method-getTemplateForTask'>    /**
</span>     * Returns the template for the task. Override this template method to supply your own custom UI template for a certain type of task.
     *
     * @template
     * @protected
     * @param {Gnt.model.Task} task The task to get template for.
     * @param {Boolean} isBaseline True to return the template for a baseline version of the task.
     * @return {Gnt.template.Template} Template for the task.
     */
    getTemplateForTask : function (task, isBaseline) {
        if (task.isMilestone(isBaseline)) {
            return this.milestoneTemplate;
        }

        if (task.isLeaf()) {
            return this.eventTemplate;
        }

        return this.parentEventTemplate;
    },

<span id='Gnt-view-Gantt-method-refreshParentNode'>    refreshParentNode : function (record) {
</span>        var parent = record.parentNode;
        if (parent) {
            this.refreshNode(parent);
        }
    },

<span id='Gnt-view-Gantt-method-refreshNotReadOnlyChildNodes'>    refreshNotReadOnlyChildNodes : function (record) {
</span>        record.cascadeBy({
            // if a child is explicitly marked as readonly then parent readonly change
            // doesn't affect the child state so we don't cascade it or its children
            before : function (child) {
                return child == record || !child.getReadOnly();
            },
            after : function (child) {
                if (child !== record) {
                    this.refreshNode(child);
                }
            },
            scope : this
        });
    },

<span id='Gnt-view-Gantt-method-setShowRollupTasks'>    setShowRollupTasks : function (show) {
</span>
        this.showRollupTasks = show;

        var parentNodes = {};

        this.taskStore.getRootNode().cascadeBy(function (node) {

            if (node.getRollup()) {
                var parentNode = node.parentNode;

                parentNodes[parentNode.internalId] = parentNode;
            }
        });

        for (var id in parentNodes) {
            var index = this.store.indexOf(parentNodes[id]);

            if (index &gt;= 0) {
                this.refreshNode(index);
            }
        }
    },

<span id='Gnt-view-Gantt-method-getRollupRenderData'>    //Todo combine generic parts this function with columnRenderer
</span>    getRollupRenderData : function (parentModel) {

        var rollupData  = [];

        var ta          = this.timeAxis,
            viewStart   = ta.getStart(),
            viewEnd     = ta.getEnd();

        for (var i = 0; i &lt; parentModel.childNodes.length; i++) {

            var taskModel = parentModel.childNodes[i];
            var taskStart = taskModel.getStartDate();
            var taskEnd   = taskModel.getEndDate() || taskStart &amp;&amp; Sch.util.Date.add(taskStart, taskModel.getDurationUnit() || Sch.util.Date.DAY, 1);

            if (taskModel.getRollup() &amp;&amp; taskStart &amp;&amp; taskEnd) {

                if (Sch.util.Date.intersectSpans(taskStart, taskEnd, viewStart, viewEnd)) {

                   var data = {}, isMileStone = taskModel.isMilestone();

                   data.isRollup = true;
                   data.id = 'rollup_' + taskModel.getId();

                    var endsOutsideView  = taskEnd &gt; viewEnd,
                        startsInsideView = Sch.util.Date.betweenLesser(taskStart, viewStart, viewEnd),
                        taskStartX       = Math.floor(this.getXFromDate(startsInsideView ? taskStart : viewStart)),
                        taskEndX         = Math.floor(this.getXFromDate(endsOutsideView ? viewEnd : taskEnd)),
                        itemWidth        = isMileStone ? 0 : taskEndX - taskStartX;

                    data.offset = (isMileStone ? (taskEndX || taskStartX) - this.getXOffset(taskModel) : taskStartX);
                    data.tpl    = isMileStone ? this.milestoneTemplate : this.eventTemplate;
                    data.cls    = taskModel.getCls();
                    data.ctcls  = '';
                    data.record = taskModel;

                    if (isMileStone) {
                        data.side = Ext.isIE8m ? Math.round(0.3 * this.getRowHeight()) : Math.round(0.5 * this.getRowHeight());
                        data.ctcls += &quot; sch-gantt-milestone&quot;;
                    } else {
                        data.width = Math.max(1, itemWidth);

                        if (endsOutsideView) {
                            data.ctcls += ' sch-event-endsoutside ';
                        }

                        if (!startsInsideView) {
                            data.ctcls += ' sch-event-startsoutside ';
                        }

                        data.ctcls += &quot; sch-gantt-task&quot;;
                    }

                    data.cls += &quot; sch-rollup-task&quot;;

                    rollupData.push(data);
                }
            }
        }

        return rollupData;
    },

<span id='Gnt-view-Gantt-method-getLabelRenderData'>    getLabelRenderData : function (taskModel) {
</span>        var lField     = this.leftLabelField,
            rField     = this.rightLabelField,
            tField     = this.topLabelField,
            bField     = this.bottomLabelField,
            renderData = {};

        if (lField) {
            renderData.leftLabel = Ext.util.Format.htmlEncode(lField.renderer.call(lField.scope || this, taskModel.data[lField.dataIndex], taskModel));
        }

        if (rField) {
            renderData.rightLabel = Ext.util.Format.htmlEncode(rField.renderer.call(rField.scope || this, taskModel.data[rField.dataIndex], taskModel));
        }

        if (tField) {
            renderData.topLabel = Ext.util.Format.htmlEncode(tField.renderer.call(tField.scope || this, taskModel.data[tField.dataIndex], taskModel));
        }

        if (bField) {
            renderData.bottomLabel = Ext.util.Format.htmlEncode(bField.renderer.call(bField.scope || this, taskModel.data[bField.dataIndex], taskModel));
        }

        return renderData;
    },

<span id='Gnt-view-Gantt-method-columnRenderer'>    // private
</span>    columnRenderer    : function (value, meta, taskModel) {
        var taskStart   = taskModel.getStartDate(),
            ta          = this.timeAxis,
            D           = Sch.util.Date,
            tplData     = {},
            cellResult  = '',
            ctcls       = '',
            viewStart   = ta.getStart(),
            viewEnd     = ta.getEnd(),
            isMilestone = taskModel.isMilestone(),
            labelsRenderDataPrepared = false,
            userData, startsInsideView, endsOutsideView;

        if (taskStart) {
            var taskEnd         = taskModel.getEndDate() || D.add(taskStart, taskModel.getDurationUnit() || D.DAY, 1),
                tick            = ta.getAt(0),
                // milliseconds per pixel ratio
                msPerPx         = (tick.getEndDate() - tick.getStartDate()) / this.timeAxisViewModel.getTickWidth(),
                timeDelta       = msPerPx * this.outsideLabelsGatherWidth,
                // if task belongs to the visible time span
                doRender        = D.intersectSpans(taskStart, taskEnd, viewStart, viewEnd),
                renderBuffer    = this.outsideLabelsGatherWidth &gt; 0,
                // if task belongs to the buffered zone before/after visible time span
                renderAfter     = renderBuffer &amp;&amp; D.intersectSpans(taskStart, taskEnd, viewEnd, new Date(viewEnd.getTime() + timeDelta)),
                renderBefore    = renderBuffer &amp;&amp; D.intersectSpans(taskStart, taskEnd, new Date(viewStart.getTime() - timeDelta), viewStart);

            // if task belongs to the visible time span
            // or belongs to the buffered zone before/after visible time span
            if (doRender || renderAfter || renderBefore) {
                endsOutsideView     = taskEnd &gt; viewEnd;
                startsInsideView    = D.betweenLesser(taskStart, viewStart, viewEnd);

                var taskStartX, taskEndX, itemWidth;

                // regular case ..task intersects visible time span
                if (doRender) {
                    taskStartX  = Math.floor(this.getXFromDate(startsInsideView ? taskStart : viewStart));
                    taskEndX    = Math.floor(this.getXFromDate(endsOutsideView ? viewEnd : taskEnd));
                    itemWidth   = isMilestone ? 0 : taskEndX - taskStartX;
                // task belongs to the buffered zone before/after visible time span
                } else {
                    startsInsideView = true;
                    itemWidth = 0;

                    if (renderAfter) {
                        taskStartX  = Math.floor(this.getXFromDate(viewEnd) + (taskStart - viewEnd) / msPerPx);
                    } else {
                        taskStartX  = Math.floor(this.getXFromDate(viewStart) - (viewStart - taskEnd) / msPerPx);
                    }
                }

                var taskOffset = isMilestone ? (taskEndX || taskStartX) - this.getXOffset(taskModel) : taskStartX;

                // if task is partially hidden progress bar should be rendered accordingly
                // eg. task is halfway done and rendered only half of the task
                // progress bar in this case should be hidden (width is 0)
                var percentDone = Math.min(taskModel.getPercentDone() || 0, 100) / 100,
                    percentDoneAtDate,
                    percentDoneX,
                    progressBarWidth;

                var parts   = taskModel.getSegments(),
                    segments;

                // if task is split
                if (parts) {
                    var percentDoneDuration = 0,
                        partsNumber         = parts.length,
                        i, part;

                    // since task is fragmented we cannot use just: (taskEnd - taskStart) * percentDone
                    // we have to get sum of all parts instead
                    for (i = 0; i &lt; partsNumber; i++) {
                        part                = parts[i];
                        percentDoneDuration += (part.getEndDate() - part.getStartDate()) * percentDone;
                    }

                    segments    = [];

                    var partStartX, partEndX, partStartDate, partEndDate;

                    for (i = 0; i &lt; partsNumber; i++) {

                        part            = parts[i];

                        var segment     = {},
                            segmentCls  = part.getCls() || '';

                        partEndDate     = part.getEndDate() || taskModel.getStartDate();
                        partStartDate   = part.getStartDate();

                        // if this segment starts in the visible area
                        if (D.betweenLesser(partStartDate, viewStart, viewEnd)) {
                            partStartX      = Math.floor(this.getXFromDate( partStartDate ));

                            // if it ends in visible area as well
                            if (D.betweenLesser(partEndDate, viewStart, viewEnd)) {
                                partEndX    = Math.floor(this.getXFromDate( partEndDate ));
                            } else {
                                partEndX    = Math.floor(this.getXFromDate( viewEnd ));
                            }

                        // if its start is invisible
                        } else {
                            partStartX  = Math.floor(this.getXFromDate( viewStart ));

                            // if end is visible
                            if (D.betweenLesser(partEndDate, viewStart, viewEnd)) {
                                partEndX    = Math.floor(this.getXFromDate( partEndDate ));

                            // if both ends are invisible lets move them outside of visible area
                            } else if (partStartDate &gt; viewEnd &amp;&amp; partEndDate &gt; viewEnd) {
                                partStartX  = partEndX = Math.floor(this.getXFromDate( viewEnd )) + 100;
                            } else if (partStartDate &lt; viewStart &amp;&amp; partEndDate &lt; viewStart) {
                                partStartX  = partEndX = Math.floor(this.getXFromDate( viewStart )) - 100;

                            // if segment start before view start and ends after view end
                            } else {
                                partEndX    = Math.floor(this.getXFromDate( viewEnd ));
                            }
                        }


                        segment.left    = partStartX - taskStartX;
                        segment.width   = partEndX - partStartX;

                        if (!percentDoneAtDate) {

                            percentDoneDuration     -= (partEndDate - partStartDate);

                            if (percentDoneDuration &lt;= 0) {

                                percentDoneAtDate   = D.add(partEndDate, D.MILLI, percentDoneDuration);

                                // mark part that has progress bar slider
                                segmentCls          += ' sch-segment-in-progress';

                                percentDoneX        = Math.floor(this.getXFromDate(percentDoneAtDate));

                                // get progress bar size for this part
                                segment.progressBarWidth    = Math.min(Math.abs(percentDoneX - partStartX), segment.width);

                            // all parts before the time span that has &quot;percentDoneAtDate&quot; have 100% percent done
                            } else {
                                segment.progressBarWidth    = part.width;
                            }

                        // all parts after the time span that has &quot;percentDoneAtDate&quot; have zero percent done
                        } else {
                            segment.progressBarWidth        = 0;
                        }

                        segment.percentDone   = percentDone * 100;

                        Ext.apply(segment, part.data);

                        segment.cls             = segmentCls;
                        segment.SegmentIndex    = i;

                        segments.push(segment);
                    }

                    segments[0].cls                 += ' sch-gantt-task-segment-first';
                    segments[partsNumber - 1].cls   += ' sch-gantt-task-segment-last';

                // if task is NOT split
                } else {

                    // picks date between task start and end according to percentDone value
                    percentDoneAtDate = new Date((taskEnd - taskStart) * percentDone + taskStart.getTime());

                    if (percentDoneAtDate &lt; viewStart) {
                        percentDoneAtDate = viewStart;
                    } else if (percentDoneAtDate &gt; viewEnd) {
                        percentDoneAtDate = viewEnd;
                    }

                }

                percentDoneX = Math.floor(this.getXFromDate(percentDoneAtDate));

                // what if rtl?
                // in case task is rendered outside of view and has width 0, we should also set progress bar
                // width to 0 or progress bar will be visible as a 1px width vertical lines
                progressBarWidth = Math.min(Math.abs(percentDoneX - taskStartX), itemWidth);

                // Data provided to the Task XTemplate is composed in these steps
                //
                // 1. Get the default data from the Task Model
                // 2. Apply internal rendering properties: id, sizing, position etc
                // 3. Allow user to add extra properties at runtime using the eventRenderer template method
                tplData = Ext.apply({}, {
                    // Core properties
                    id               : taskModel.internalId + '-x-x',
                    offset           : taskOffset,
                    width            : Math.max(1, itemWidth),
                    ctcls            : '',
                    cls              : '',
                    print            : this._print,
                    record           : taskModel,
                    percentDone      : percentDone * 100,
                    progressBarWidth : Math.max(0, progressBarWidth - 2*this.eventBorderWidth),
                    segments         : segments
                }, taskModel.data);

                // Get data from user &quot;renderer&quot;
                userData = this.eventRenderer.call(this.eventRendererScope || this, taskModel, tplData, taskModel.store) || {};

                // Labels

                Ext.apply(tplData, this.getLabelRenderData(taskModel));

                labelsRenderDataPrepared = true;

                Ext.apply(tplData, userData);

                var dataCls = ' sch-event-resizable-' + taskModel.getResizable();

                if (isMilestone) {
                    tplData.side = Math.round((this.enableBaseline ? 0.4 : 0.5) * this.getRowHeight());
                    ctcls += &quot; sch-gantt-milestone&quot;;
                } else {
                    tplData.width = Math.max(1, itemWidth);

                    if (endsOutsideView) {
                        ctcls += ' sch-event-endsoutside ';
                    }

                    if (!startsInsideView) {
                        ctcls += ' sch-event-startsoutside ';
                    }

                    if (taskModel.isLeaf()) {
                        ctcls += &quot; sch-gantt-task&quot;;
                    } else {
                        ctcls += &quot; sch-gantt-parent-task&quot;;
                    }

                }

                if (taskModel.isReadOnly()) {
                    ctcls += &quot; sch-gantt-task-readonly&quot;;
                }

                if (taskModel.isProject) {
                    ctcls += &quot; sch-gantt-project-task&quot;;
                }

                if (taskModel.dirty)                    dataCls += ' sch-dirty ';
                if (taskModel.isDraggable() === false)  dataCls += ' sch-event-fixed ';

                dataCls += taskModel.isSegmented() ? ' sch-event-segmented ' :  ' sch-event-notsegmented ';

                tplData.cls = (tplData.cls || '') + (taskModel.getCls() || '') + dataCls;
                tplData.ctcls += ' ' + ctcls;

                if (this.showRollupTasks) {

                    var rollupData = this.getRollupRenderData(taskModel);

                    if (rollupData.length &gt; 0) {
                        cellResult += this.rollupTemplate.apply(rollupData);
                    }
                }

                cellResult += this.getTemplateForTask(taskModel).apply(tplData);
            }
        }

        // if baselines enabled
        if (this.enableBaseline) {

            // userData might be not initialized if we do not render the task bar (unscheduled or out of visible span)
            if (!userData) {
                userData    = this.eventRenderer.call(this, taskModel, tplData, taskModel.store) || {};
            }

            // render baseline bar
            cellResult += this.baselineRenderer(taskModel, userData, viewStart, viewEnd, labelsRenderDataPrepared);
        }

        return cellResult;
    },


<span id='Gnt-view-Gantt-method-baselineRenderer'>    baselineRenderer : function (taskModel, userData, viewStart, viewEnd, labelsRenderDataPrepared) {
</span>        var D                   = Sch.util.Date,
            taskBaselineStart   = taskModel.getBaselineStartDate(),
            taskBaselineEnd     = taskModel.getBaselineEndDate();

        if (taskBaselineStart &amp;&amp; taskBaselineEnd &amp;&amp; D.intersectSpans(taskBaselineStart, taskBaselineEnd, viewStart, viewEnd)) {
            var endsOutsideView             = taskBaselineEnd &gt; viewEnd;
            var startsInsideView            = D.betweenLesser(taskBaselineStart, viewStart, viewEnd);

            var isBaselineMilestone     = taskModel.isBaselineMilestone(),
                baseStartX              = Math.floor(this.getXFromDate(startsInsideView ? taskBaselineStart : viewStart)),
                baseEndX                = Math.floor(this.getXFromDate(endsOutsideView ? viewEnd : taskBaselineEnd)),
                baseWidth               = Math.max(1, isBaselineMilestone ? 0 : baseEndX - baseStartX),
                baseTpl                 = this.getTemplateForTask(taskModel, true),
                data                    = {
                    progressBarStyle : userData.baseProgressBarStyle || '',
                    // Putting 'base-' as suffix ('-base') conflicts with task element id creating rules where
                    // task element id is [commonprefix]-(task.internalId)-(resource.internalId)-(partnum)
                    id               : 'base-' + taskModel.internalId,
                    // TODO this should use same rendering as the regular task
                    progressBarWidth : Math.min(100, taskModel.getBaselinePercentDone()) * baseWidth / 100,
                    percentDone      : taskModel.getBaselinePercentDone(),
                    offset           : isBaselineMilestone ? (baseEndX || baseStartX) - this.getXOffset(taskModel, true) : baseStartX,
                    print            : this._print,
                    width            : Math.max(1, baseWidth),
                    baseline         : true
                };

            var ctcls                   = '';

            if (isBaselineMilestone) {
                data.side               = Math.round(0.40 * this.getRowHeight());
                ctcls                   = &quot;sch-gantt-milestone-baseline sch-gantt-baseline-item&quot;;
            } else if (taskModel.isLeaf()) {
                ctcls                   = &quot;sch-gantt-task-baseline sch-gantt-baseline-item&quot;;
            } else {
                ctcls                   = &quot;sch-gantt-parenttask-baseline sch-gantt-baseline-item&quot;;
            }

            if (endsOutsideView) {
                ctcls                   += ' sch-event-endsoutside ';
            }

            if (!startsInsideView) {
                ctcls                   += ' sch-event-startsoutside ';
            }

            // HACK, a bit inconsistent. 'basecls' should probably end up on the task el instead of the wrapper.
            data.ctcls                  = ctcls + ' ' + (userData.basecls || '');

            if (!labelsRenderDataPrepared) {
                Ext.apply(data, this.getLabelRenderData(taskModel));
            }

            return baseTpl.apply(data);
        }

        return '';
    },


<span id='Gnt-view-Gantt-method-setupTemplates'>    setupTemplates : function () {
</span>
        var tplCfg = {
            leftLabel                : this.leftLabelField,
            rightLabel               : this.rightLabelField,
            topLabel                 : this.topLabelField,
            bottomLabel              : this.bottomLabelField,
            prefix                   : this.eventPrefix,
            resizeHandles            : this.resizeHandles,
            enableDependencyDragDrop : this.enableDependencyDragDrop !== false,
            allowParentTaskDependencies : this.allowParentTaskDependencies !== false,
            enableProgressBarResize  : this.enableProgressBarResize,
            rtl                      : this.rtl
        };

        var config;

        if (!this.eventTemplate) {
            config = this.taskBodyTemplate ? Ext.apply({ innerTpl : this.taskBodyTemplate }, tplCfg) : tplCfg;
            this.eventTemplate = Ext.create(&quot;Gnt.template.Task&quot;, config);
        }

        if (!this.parentEventTemplate) {
            config = this.parentTaskBodyTemplate ? Ext.apply({ innerTpl : this.parentTaskBodyTemplate }, tplCfg) : tplCfg;
            this.parentEventTemplate = Ext.create(&quot;Gnt.template.ParentTask&quot;, config);
        }

        if (!this.milestoneTemplate) {
            config = this.milestoneBodyTemplate ? Ext.apply({ innerTpl : this.milestoneBodyTemplate }, tplCfg) : tplCfg;
            this.milestoneTemplate = Ext.create(&quot;Gnt.template.Milestone&quot;, config);
        }

        if (!this.rollupTemplate) {
            this.rollupTemplate = Ext.create(&quot;Gnt.template.RollupTask&quot;, tplCfg);
        }
    },

<span id='Gnt-view-Gantt-method-getDependencyView'>    /**
</span>     * Wrapper function returning the dependency manager instance
     * @return {Gnt.view.Dependency} dependencyManager The dependency manager instance
     */
    getDependencyView : function () {
        return this.dependencyView;
    },


<span id='Gnt-view-Gantt-method-getTaskStore'>    /**
</span>     * Returns the associated task store
     * @return {Gnt.data.TaskStore}
     */
    getTaskStore     : function () {
        return this.taskStore;
    },

<span id='Gnt-view-Gantt-method-initDependencies'>    // private
</span>    initDependencies : function () {

        if (this.dependencyStore) {
            var me = this,
                dv = Ext.create(&quot;Gnt.view.Dependency&quot;, Ext.apply({
                    containerEl              : me.el,
                    ganttView                : me,
                    enableDependencyDragDrop : me.enableDependencyDragDrop,
                    allowParentTaskDependencies : me.allowParentTaskDependencies,
                    store                    : me.dependencyStore,
                    rtl                      : me.rtl
                }, this.dependencyViewConfig));

            dv.on({
                beforednd     : me.onBeforeDependencyDrag,
                dndstart      : me.onDependencyDragStart,
                drop          : me.onDependencyDrop,
                afterdnd      : me.onAfterDependencyDragDrop,
                scope         : me
            });

            me.dependencyView = dv;

            me.relayEvents(dv, [
<span id='Gnt-view-Gantt-event-dependencyclick'>            /**
</span>             * @event dependencyclick
             * Fires after clicking on a dependency line/arrow
             * @param {Gnt.view.Dependency} view The dependency view instance
             * @param {Gnt.model.Dependency} record The dependency record
             * @param {Ext.EventObject} event The event object
             * @param {HTMLElement} target The target of this event
             */
                'dependencyclick',

<span id='Gnt-view-Gantt-event-dependencycontextmenu'>            /**
</span>             * @event dependencycontextmenu
             * Fires after right clicking on a dependency line/arrow
             * @param {Gnt.view.Dependency} view The dependency view instance
             * @param {Gnt.model.Dependency} record The dependency record
             * @param {Ext.EventObject} event The event object
             * @param {HTMLElement} target The target of this event
             */
                'dependencycontextmenu',

<span id='Gnt-view-Gantt-event-dependencydblclick'>            /**
</span>             * @event dependencydblclick
             * Fires after double clicking on a dependency line/arrow
             * @param {Gnt.view.Dependency} view The dependency view instance
             * @param {Gnt.model.Dependency} record The dependency record
             * @param {Ext.EventObject} event The event object
             * @param {HTMLElement} target The target of this event
             */
                'dependencydblclick'
            ]);
        }
    },

<span id='Gnt-view-Gantt-method-setupGanttEvents'>    // private
</span>    setupGanttEvents : function () {
        var taskStore = this.taskStore;

        if (this.toggleParentTasksOnClick) {
            this.on({
                taskclick : function (view, model) {

                    if (!model.isLeaf() &amp;&amp; (!taskStore.isTreeFiltered() || taskStore.allowExpandCollapseWhileFiltered)) {
                        var me = this;

                        // Since row is being repainted in the DOM, no native 'dblclick' event will be fired
                        // We need to detect this case and fake it
                        var dblClickHandler = function() {
                            this.fireEvent.apply(this, ['taskdblclick'].concat(Array.prototype.slice.apply(arguments)));
                        };

                        this.on('taskclick', dblClickHandler);

                        // Remove listener after 300ms
                        setTimeout(function() {
                            me.un('taskclick', dblClickHandler);
                        }, 300);

                        model.isExpanded() ? model.collapse() : model.expand();
                    }
                }
            });
        }
    },

<span id='Gnt-view-Gantt-method-configureLabels'>    // private
</span>    configureLabels  : function () {

        var defaults = {
            renderer  : function (v) {
                return v;
            },
            dataIndex : undefined
        };

        Ext.Array.forEach(['left', 'right', 'top', 'bottom'], function(pos) {

            var field = this[pos+'LabelField'];

            if (field) {
                if (Ext.isString(field)) {
                    field = this[pos + 'LabelField'] = { dataIndex : field };
                }
                Ext.applyIf(field, defaults);

                // Initialize editor (if defined)
                if (field.editor) {
                    field.editor = Ext.create(&quot;Gnt.feature.LabelEditor&quot;, this, {
                        labelPosition : pos,
                        field         : field.editor,
                        dataIndex     : field.dataIndex
                    });
                }
            }
        }, this);

        this.on('labeledit_beforestartedit', this.onBeforeLabelEdit, this);
    },

<span id='Gnt-view-Gantt-method-onBeforeTaskDrag'>    // private
</span>    onBeforeTaskDrag : function (p, record) {
        return !this.readOnly &amp;&amp; record.isDraggable() !== false &amp;&amp; (this.allowParentTaskMove || record.isLeaf());
    },

<span id='Gnt-view-Gantt-method-onDragDropStart'>    onDragDropStart : function () {
</span>        if (this.tip) {
            // HACK tip disable doesn't work in Ext 5.1
            // http://www.sencha.com/forum/showthread.php?296286-Ext.Tooltip-disable-doesn-t-work-in-5.1&amp;p=1081931#post1081931
            this.tip.on('beforeshow', this.falseReturningFn);
        }
    },

<span id='Gnt-view-Gantt-method-falseReturningFn'>    falseReturningFn : function() { return false; },
</span>
<span id='Gnt-view-Gantt-method-onDragDropEnd'>    onDragDropEnd : function () {
</span>        if (this.tip) {
            this.tip.un('beforeshow', this.falseReturningFn);
        }
    },

<span id='Gnt-view-Gantt-method-onTaskProgressBarResizeStart'>    onTaskProgressBarResizeStart : function () {
</span>        if (this.tip) {
            this.tip.hide();
            this.tip.disable();
        }
    },

<span id='Gnt-view-Gantt-method-onTaskProgressBarResizeEnd'>    onTaskProgressBarResizeEnd : function () {
</span>        if (this.tip) {
            this.tip.enable();
        }
    },

<span id='Gnt-view-Gantt-method-onTaskResizeStart'>    onTaskResizeStart : function () {
</span>        if (this.tip) {
            this.tip.hide();
            this.tip.disable();
        }

        // TODO review for Ext 5.1.
        // While resizing a task, we don't want the scroller to interfere
        if (this.scrollManager) {
            this.scrollManager.scroller.setDisabled(true);
        }
    },

<span id='Gnt-view-Gantt-method-onTaskResizeEnd'>    onTaskResizeEnd : function () {
</span>        if (this.tip) {
            this.tip.enable();
        }

        // TODO review for Ext 5.1.
        // While resizing a task, we don't want the scroller to interfere
        if (this.scrollManager) {
            this.scrollManager.scroller.setDisabled(false);
        }
    },

<span id='Gnt-view-Gantt-method-onBeforeDragCreate'>    // private
</span>    onBeforeDragCreate : function () {
        return !this.readOnly;
    },

<span id='Gnt-view-Gantt-method-onBeforeTaskResize'>    // private
</span>    onBeforeTaskResize : function (view, task) {
        return !this.readOnly &amp;&amp; task.getSchedulingMode() !== 'EffortDriven';
    },

<span id='Gnt-view-Gantt-method-onBeforeTaskProgressBarResize'>    onBeforeTaskProgressBarResize : function () {
</span>        return !this.readOnly;
    },

<span id='Gnt-view-Gantt-method-onBeforeLabelEdit'>    onBeforeLabelEdit : function () {
</span>        return !this.readOnly;
    },

<span id='Gnt-view-Gantt-method-afterRender'>    afterRender : function () {
</span>        this.initDependencies();
        this.callParent(arguments);

        this.el.on('mousemove', this.configureFeatures, this, { single : true });

        Ext.dd.ScrollManager.register(this.el);
    },

<span id='Gnt-view-Gantt-method-resolveTaskRecord'>    resolveTaskRecord : function (el) {
</span>        var node = this.findItemByChild(el);

        if (node) {
            return this.getRecord(this.findItemByChild(el));
        }
        return null;
    },

<span id='Gnt-view-Gantt-method-resolveEventRecord'>    resolveEventRecord : function (el) {
</span>        return this.resolveTaskRecord(el);
    },

<span id='Gnt-view-Gantt-method-resolveEventRecordFromResourceRow'>    resolveEventRecordFromResourceRow: function (el) {
</span>        return this.resolveTaskRecord(el);
    },

<span id='Gnt-view-Gantt-method-highlightTask'>    /**
</span>     * Highlights a task and optionally any dependent tasks. Highlighting will add the `sch-gantt-task-highlighted`
     * class to the task row element.
     *
     * @param {Mixed} task Either a task record or the id of a task
     * @param {Boolean} highlightDependentTasks `true` to highlight the depended tasks. Defaults to `true`
     *
     */
    highlightTask : function (task, highlightDependentTasks) {
        if (!(task instanceof Ext.data.Model)) {
            task = this.taskStore.getModelById(task);
        }

        if (task) {
            task.isHighlighted = true;

            var el = this.getRow(task);
            if (el) {
                Ext.fly(el).addCls('sch-gantt-task-highlighted');
            }

            if (highlightDependentTasks !== false) {
                for (var i = 0, l = task.successors.length; i &lt; l; i++) {
                    var dep     = task.successors[ i ];

                    this.highlightDependency(dep);
                    this.highlightTask(dep.getTargetTask(), highlightDependentTasks);
                }
            }
        }
    },


<span id='Gnt-view-Gantt-method-unhighlightTask'>    /**
</span>     * Un-highlights a task and optionally any dependent tasks.
     *
     * @param {Mixed} task Either a task record or the id of a task
     * @param {Boolean} includeSuccessorTasks `true` to also highlight successor tasks. Defaults to `true`
     *
     */
    unhighlightTask : function (task, includeSuccessorTasks) {
        if (!(task instanceof Ext.data.Model)) {
            task = this.taskStore.getModelById(task);
        }

        if (task) {
            task.isHighlighted = false;

            var el = this.getRow(task);
            if (el) {
                Ext.fly(el).removeCls('sch-gantt-task-highlighted');
            }

            if (includeSuccessorTasks !== false) {
                for (var i = 0, l = task.successors.length; i &lt; l; i++) {
                    var dep     = task.successors[ i ];

                    this.unhighlightDependency(dep);
                    this.unhighlightTask(dep.getTargetTask(), includeSuccessorTasks);
                }
            }
        }
    },


<span id='Gnt-view-Gantt-method-getRowClass'>    getRowClass : function (task) {
</span>        var cls = '';

        if (task.isHighlighted) cls = 'sch-gantt-task-highlighted';

        if (this.externalGetRowClass) cls += ' ' + (this.externalGetRowClass.apply(this, arguments) || '');

        return cls;
    },


<span id='Gnt-view-Gantt-method-clearSelectedTasksAndDependencies'>    // private
</span>    clearSelectedTasksAndDependencies : function () {
        this.getDependencyView().clearSelectedDependencies();
        this.el.select('.sch-gantt-task-highlighted').removeCls('sch-gantt-task-highlighted');

        this.taskStore.getRootNode().cascadeBy(function (task) {
            task.isHighlighted = false;
        });
    },


<span id='Gnt-view-Gantt-method-getCriticalPaths'>    /**
</span>     * Returns the critical path(s) that can affect the end date of the project
     * @return {Array} paths An array of arrays (containing task chains)
     */
    getCriticalPaths : function () {
        return this.taskStore.getCriticalPaths();
    },


<span id='Gnt-view-Gantt-method-highlightCriticalPaths'>    /**
</span>     * Highlights the critical path(s) that can affect the end date of the project.
     */
    highlightCriticalPaths : function () {
        // First clear any selected tasks/dependencies
        this.clearSelectedTasksAndDependencies();

        var paths   = this.getCriticalPaths(),
            dm      = this.getDependencyView(),
            t, i, l, depRecord;

        Ext.Array.forEach(paths, function (tasks) {
            for (i = 0, l = tasks.length; i &lt; l; i++) {
                t = tasks[i];
                this.highlightTask(t, false);

                if (i &lt; l - 1) {

                    for (var j = 0, m = t.predecessors.length; j &lt; m; j++) {
                        if (t.predecessors[j].getSourceId() == tasks[i + 1].getId()) {
                            depRecord = t.predecessors[j];
                            break;
                        }
                    }

                    dm.highlightDependency(depRecord);
                }
            }
        }, this);

        this.addCls('sch-gantt-critical-chain');
    },


<span id='Gnt-view-Gantt-method-unhighlightCriticalPaths'>    /**
</span>     * Removes the highlighting of the critical path(s).
     */
    unhighlightCriticalPaths : function () {
        this.removeCls('sch-gantt-critical-chain');

        this.clearSelectedTasksAndDependencies();
    },


<span id='Gnt-view-Gantt-method-getXOffset'>    //private
</span>    getXOffset               : function (task, isBaseline) {
        var offset      = 0;

        if (task.isMilestone(isBaseline)) {
            // For milestones, the offset should be half the square diagonal
            offset      = Math.floor(this.getRowHeight() * Math.sqrt(2) / 4) - 2;
        }

        return offset;
    },

<span id='Gnt-view-Gantt-method-onDestroy'>    //private
</span>    onDestroy                : function () {
        if (this.dependencyView) {
            this.dependencyView.destroy();
        }

        if (this.rendered) Ext.dd.ScrollManager.unregister(this.el);

        this.callParent(arguments);
    },

<span id='Gnt-view-Gantt-method-highlightDependency'>    /**
</span>     * Convenience method wrapping the dependency manager method which highlights the elements representing a particular dependency
     * @param {Mixed} record Either the id of a record or a record in the dependency store
     */
    highlightDependency : function (record) {
        this.dependencyView.highlightDependency(record);
    },

<span id='Gnt-view-Gantt-method-unhighlightDependency'>    /**
</span>     * Convenience method wrapping the dependency manager method which unhighlights the elements representing a particular dependency
     * @param {Mixed} depId Either the id of a record or a record in the dependency store
     */
    unhighlightDependency  : function (record) {
        this.dependencyView.unhighlightDependency(record);
    },


<span id='Gnt-view-Gantt-method-onBeforeDependencyDrag'>    // private
</span>    onBeforeDependencyDrag : function (dm, sourceTask) {
        return this.fireEvent('beforedependencydrag', this, sourceTask);
    },

<span id='Gnt-view-Gantt-method-onDependencyDragStart'>    // private
</span>    onDependencyDragStart  : function (dm) {
        this.fireEvent('dependencydragstart', this);

        if (this.tip) {
            this.tip.disable();
        }

        this.preventOverCls = true;
    },

<span id='Gnt-view-Gantt-method-onDependencyDrop'>    onDependencyDrop          : function (dm, fromId, toId, type) {
</span>        this.fireEvent('dependencydrop', this, this.taskStore.getModelById(fromId), this.taskStore.getModelById(toId), type);
    },

<span id='Gnt-view-Gantt-method-onAfterDependencyDragDrop'>    // private
</span>    onAfterDependencyDragDrop : function () {
        this.fireEvent('afterdependencydragdrop', this);

        // Enable tooltip after drag again
        if (this.tip) {
            this.tip.enable();
        }

        this.preventOverCls = false;
    },

<span id='Gnt-view-Gantt-method-getLeftEditor'>    /**
</span>     * Returns the editor defined for the left task field
     * @return {Gnt.feature.LabelEditor} editor The editor
     */
    getLeftEditor : function () {
        return this.leftLabelField &amp;&amp; this.leftLabelField.editor;
    },

<span id='Gnt-view-Gantt-method-getRightEditor'>    /**
</span>     * Returns the editor defined for the right task field
     * @return {Gnt.feature.LabelEditor} editor The editor
     */
    getRightEditor : function () {
        return this.rightLabelField &amp;&amp; this.rightLabelField.editor;
    },

<span id='Gnt-view-Gantt-method-getTopEditor'>    /**
</span>     * Returns the editor defined for the top task field
     * @return {Gnt.feature.LabelEditor} editor The editor
     */
    getTopEditor : function () {
        return this.topLabelField &amp;&amp; this.topLabelField.editor;
    },

<span id='Gnt-view-Gantt-method-getBottomEditor'>    /**
</span>     * Returns the editor defined for the bottom task field
     * @return {Gnt.feature.LabelEditor} editor The editor
     */
    getBottomEditor : function () {
        return this.bottomLabelField &amp;&amp; this.bottomLabelField.editor;
    },

<span id='Gnt-view-Gantt-method-editLeftLabel'>    /**
</span>     * Programmatically activates the editor for the left field
     * @param {Gnt.model.Task} record The task record
     */
    editLeftLabel : function (record) {
        var ed = this.getLeftEditor();
        if (ed) {
            ed.edit(record);
        }
    },

<span id='Gnt-view-Gantt-method-editRightLabel'>    /**
</span>     * Programmatically activates the editor for the right field
     * @param {Gnt.model.Task} record The task record
     */
    editRightLabel : function (record) {
        var ed = this.getRightEditor();
        if (ed) {
            ed.edit(record);
        }
    },

<span id='Gnt-view-Gantt-method-editTopLabel'>    /**
</span>     * Programmatically activates the editor for the top field
     * @param {Gnt.model.Task} record The task record
     */
    editTopLabel : function (record) {
        var ed = this.getTopEditor();
        if (ed) {
            ed.edit(record);
        }
    },

<span id='Gnt-view-Gantt-method-editBottomLabel'>    /**
</span>     * Programmatically activates the editor for the bottom field
     * @param {Gnt.model.Task} record The task record
     */
    editBottomLabel : function (record) {
        var ed = this.getBottomEditor();
        if (ed) {
            ed.edit(record);
        }
    },

<span id='Gnt-view-Gantt-method-getDependenciesForTask'>    // deprecated
</span>    getDependenciesForTask : function (record) {
        // &lt;debug&gt;
        window.console &amp;&amp; console.warn &amp;&amp; console.warn('`ganttPanel.getDependenciesForTask()` is deprecated, use `task.getAllDependencies()` instead');
        // &lt;/debug&gt;
        return record.getAllDependencies();
    },

    // Performance tweak, preventing extra layout cycles
    // @OVERRIDE
    //onAdd                          : function () {
    //    Ext.suspendLayouts();
    //    this.callParent(arguments);
    //    Ext.resumeLayouts();
    //},

    // Performance tweak, preventing extra layout cycles
    // @OVERRIDE
    //onRemove                       : function () {
    //    Ext.suspendLayouts();
    //    this.callParent(arguments);
    //    Ext.resumeLayouts();
    //},

<span id='Gnt-view-Gantt-method-onUpdate'>    // @OVERRIDE
</span>    // Preventing extra reflows due to the expensive re-layout performed by the superclass
    onUpdate : function (store, record, operation) {
        //Ext.suspendLayouts();
        this.callParent(arguments);
        //Ext.resumeLayouts();

        if (operation == Ext.data.Model.EDIT) {
            var prev = record.previous;

            if (prev) {
                // The code below will handle the redraw when user does &quot;setRollup&quot; on some task
                // However generally the parent tasks are refreshed at the end of the cascading in the `onAfterCascade` method
                // of the Gnt.panel.Gantt
                if (record.rollupField in prev || record.getRollup()) {
                    this.refreshParentNode(record);
                }

                // refresh the task child nodes when the task readOnly status changes
                if (record.readOnlyField in prev) {
                    this.refreshNotReadOnlyChildNodes(record);
                }
            }
        }
    },


<span id='Gnt-view-Gantt-method-handleScheduleEvent'>    handleScheduleEvent : function (e) {
</span>        var t = e.getTarget('.' + this.timeCellCls, 3);

        if (t) {
            var rowNode = this.findRowByChild(t);

            if (e.type.indexOf('pinch') &gt;= 0) {
                this.fireEvent('schedule' + e.type, this, e);
            } else {
                this.fireEvent('schedule' + e.type, this, this.getDateFromDomEvent(e, 'floor'), this.indexOf(rowNode), e);
            }
        }
    },


<span id='Gnt-view-Gantt-method-scrollEventIntoView'>    /**
</span>     *  Scrolls a task record into the viewport.
     *  This method will also expand all relevant parent nodes to locate the event.
     *
     *  @param {Gnt.model.Task} taskRec, the task record to scroll into view
     *  @param {Boolean/Object} highlight, either `true/false` or a highlight config object used to highlight the element after scrolling it into view
     *  @param {Boolean/Object} animate, either `true/false` or an animation config object used to scroll the element
     */
    scrollEventIntoView : function (taskRec, highlight, animate, callback, scope) {
        scope = scope || this;

        var me = this;
        var taskStore = this.taskStore;

        var basicScroll = function (el, scrollHorizontally) {

            // HACK
            // After a time axis change, the header is resized and Ext JS TablePanel reacts to the size change.
            // Ext JS reacts after a short delay, so we cancel this task to prevent Ext from messing up the scroll sync
            me.up('panel').scrollTask.cancel();

            me.scrollElementIntoView(el, scrollHorizontally, animate);

            if (highlight) {
                if (typeof highlight === &quot;boolean&quot;) {
                    el.highlight();
                } else {
                    el.highlight(null, highlight);
                }
            }

            // XXX callback will be called too early, need to wait for scroll &amp; highlight to complete
            callback &amp;&amp; callback.call(scope);
        };

        // Make sure the resource is expanded all the way up first.
        if (!taskRec.isVisible()) {
            taskRec.bubble(function (node) {
                node.expand();
            });
        }

        var targetEl;

        var startDate = taskRec.getStartDate();
        var endDate = taskRec.getEndDate();
        var isScheduled = Boolean(startDate &amp;&amp; endDate);

        if (isScheduled) {
            var timeAxis = this.timeAxis;

            // If task is not in the currently viewed time span, change time span
            if (!timeAxis.dateInAxis(startDate) || !timeAxis.dateInAxis(endDate)) {
                var range = timeAxis.getEnd() - timeAxis.getStart();

                timeAxis.setTimeSpan(new Date(startDate.getTime() - range / 2), new Date(endDate.getTime() + range / 2));
            }
            targetEl = this.getElementFromEventRecord(taskRec);
        } else {
            // No date information in the task, scroll to row element instead
            targetEl = this.getNode(taskRec);

            if (targetEl) {
                targetEl = Ext.fly(targetEl).down(this.getCellSelector());
            }
        }

        if (targetEl) {
            basicScroll(targetEl, isScheduled);
        } else {
            if (this.bufferedRenderer) {

                Ext.Function.defer(function () {
                    me.bufferedRenderer.scrollTo(taskRec, false, function () {
                        // el should be present now
                        var targetEl = me.getElementFromEventRecord(taskRec);

                        if (targetEl) {
                            basicScroll(targetEl, true);
                        } else {
                            callback &amp;&amp; callback.call(scope);
                        }
                    });

                }, 10);
            }
        }
    },

<span id='Gnt-view-Gantt-method-setRowHeight'>    setRowHeight : function (height) {
</span>        this.getDependencyView().setRowHeight(height, true);

        this.callParent(arguments);
    }
});
</pre>
</body>
</html>
