<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Gnt-data-mixin-ProjectableStore'>/**
</span> * The mixin adds transaction alike functionality into a store, works in pair with {@link Gnt.model.mixin.ProjectableModel}
 * if you mix-in this one into a store make sure you mixin in {@link Gnt.model.mixin.ProjectableModel} into store's
 * model class as well.
 *
 * NOTE: only model updates are included into a transaction, record adding/removing are not taken into account,
 * that's why it's called &quot;projection&quot;.
 */
Ext.define('Gnt.data.mixin.ProjectableStore', function() {

    function getByInternalId(store, id) {
        return store.byInternalIdMap &amp;&amp; store.byInternalIdMap[id] || store.getByInternalId(id);
    }

<span id='Gnt-data-mixin-ProjectableStore-method-getProjection'>    /**
</span>     * @private
     * @method getProjection
     * @member Gnt.data.mixin.ProjectableStore
     */
    function getProjection() {
        var me              = this,
            projectionStack = me.projectionStack;

        return projectionStack &amp;&amp; projectionStack[ projectionStack.length - 1 ];
    }


<span id='Gnt-data-mixin-ProjectableStore-method-getProjectionLevel'>    /**
</span>     * @private
     * @method getProjectionLevel
     * @member Gnt.data.mixin.ProjectableStore
     */
    function getProjectionLevel() {
        var me              = this,
            projectionStack = me.projectionStack;

        return projectionStack &amp;&amp; projectionStack.length || 0;
    }


<span id='Gnt-data-mixin-ProjectableStore-method-areProjected'>    /**
</span>     * Checks whether any of given records are projected currently, i.e. any of given records has changes in current
     * projection.
     *
     * @param {Ext.data.Model/[Ext.data.Model]} records
     * @return boolean
     */
    function areProjected(records) {
        var i, len, are;

        records = [].concat(records);

        for (are = false, i = 0, len = records.length; !are &amp;&amp; i &lt; len; i++) {
            are = records[i].isProjected();
        }

        return are;
    }


<span id='Gnt-data-mixin-ProjectableStore-method-startProjection'>    /**
</span>      * Starts store's projection, any updates to any records during projection period will be put into a projection
      * storage and might be committed into record's data by calling {@link Gnt.data.mixin.ProjectableStore#commitProjection} or
      * canceled by calling {@link Gnt.data.mixin.ProjectableStore#rejectProjection}. The primary condition for this
      * to work is that store's records must use {#link Gnt.model.mixin.ProjectableModel} mixin. Projections
      * might be nested.
      *
      * @method startProjection
      * @member Gnt.data.mixin.ProjectableStore
      */
    function startProjection() {
        var me = this,
            projectionStack = me.projectionStack,
            newProjection, prevProjection;

        if (!projectionStack) {
            me.projectionStack = [{}];
        }
        else {
            prevProjection = projectionStack[ projectionStack.length - 1 ];
            newProjection  = {};

            Ext.Object.each(prevProjection, function(id, data) {
                var dataConstructor = function() {};

                dataConstructor.prototype = data;
                newProjection[id] = new dataConstructor();
            });

            projectionStack.push(newProjection);
        }

    }


<span id='Gnt-data-mixin-ProjectableStore-method-commitProjection'>    /**
</span>     * Commits all the changes recorded since last call to {@link #startProjection}..
     *
     * @method commitProjection
     * @member Gnt.data.mixin.ProjectableStore
     */
    function commitProjection() {
        var me = this,
            projectionStack = me.projectionStack,
            projectionData, committingData,
            prop, data,
            hasUpdates,
            internalId,
            record;


        // If projection level is 0 then committing recorded updates into corresponding store's records.
        if (projectionStack.length === 1) {
            committingData     = projectionStack[0];
            me.projectionStack = null;

            for (internalId in committingData) {
                if (committingData.hasOwnProperty(internalId)) {

                    record              = getByInternalId(me, internalId);

                    // Record might have been deleted from the store during projection time
                    if (record) {
                        data                = committingData[ internalId ];
                        hasUpdates          = false;

                        for (prop in data) {
                            if (data.hasOwnProperty(prop)) {
                                hasUpdates = true;
                                break;
                            }
                        }

                        hasUpdates &amp;&amp; record.set(data);
                    }
                }
            }
        }
        // If projection level is higher then copying current projection into lower level (previous) projection
        else {
            committingData = projectionStack.pop();
            projectionData = projectionStack[ projectionStack.length - 1 ];

            for (internalId in committingData) {
                if (committingData.hasOwnProperty(internalId)) {
                    if (!projectionData.hasOwnProperty(internalId)) {
                        projectionData[ internalId ] = committingData[ internalId ];
                    }
                    else {
                        projectionData[ internalId ] = Ext.apply(projectionData[ internalId ], committingData[ internalId ]);
                    }
                }
            }
        }

        this.fireEvent('projectioncommit', this, projectionStack &amp;&amp; projectionStack[projectionStack.length - 1], committingData);
    }


<span id='Gnt-data-mixin-ProjectableStore-method-rejectProjection'>    /**
</span>     * Rejects all the changes to store's records recorded since projection last call to {@link #startProjection}.
     *
     * @method rejectProjection
     * @member Gnt.data.mixin.ProjectableStore
     */
    function rejectProjection() {
        var me              = this,
            projectionStack = me.projectionStack,
            projectionData  = projectionStack.pop();

        // If projection level was 1 (and now 0) then simply getting rid of projection stack
        if (projectionStack.length === 0) {
            me.projectionStack = null;
        }
        // If projection level is higher then we've got rid of changes recorded since last startProjection() call
        // by simply popping the last projection state from the projection stack.

        this.fireEvent('projectionreject', this, projectionStack &amp;&amp; projectionStack[projectionStack.length - 1], projectionData);
    }

    return {
        projectionStack  : null,

        getProjection      : getProjection,
        areProjected       : areProjected,
        getProjectionLevel : getProjectionLevel,
        startProjection    : startProjection,
        commitProjection   : commitProjection,
        rejectProjection   : rejectProjection
    };
});
</pre>
</body>
</html>
