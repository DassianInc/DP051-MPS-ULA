<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Gnt-widget-taskeditor-BaseForm'>/**
</span> @class Gnt.widget.taskeditor.BaseForm
 @extends Ext.form.Panel

 A mixin with common functionality for the taskform {@link Gnt.widget.taskeditor.TaskEditor}.

 */
Ext.define('Gnt.widget.taskeditor.BaseForm', {

    extend                  : 'Ext.form.Panel',

<span id='Gnt-widget-taskeditor-BaseForm-cfg-highlightTaskUpdates'>    /**
</span>     * @cfg {Boolean} highlightTaskUpdates `true` to highlight fields updates initiated by changes of another fields.
     */
    highlightTaskUpdates    : true,

<span id='Gnt-widget-taskeditor-BaseForm-cfg-task'>    /**
</span>     * @cfg {Gnt.model.Task} task A task to load to the form.
     */
<span id='Gnt-widget-taskeditor-BaseForm-property-task'>    /**
</span>     * @property {Gnt.model.Task} task The task loaded in the form.
     */
    task                    : null,

<span id='Gnt-widget-taskeditor-BaseForm-cfg-taskBuffer'>    /**
</span>     * @cfg {Gnt.model.Task} taskBuffer A task used to keep intermediate values of fields implemented by {@link Gnt.field.mixin.TaskField} mixin.
     */
<span id='Gnt-widget-taskeditor-BaseForm-property-taskBuffer'>    /**
</span>     * @property {Gnt.model.Task} taskBuffer A task used to keep intermediate values of fields implemented by {@link Gnt.field.mixin.TaskField} mixin.
     */
    taskBuffer              : null,

<span id='Gnt-widget-taskeditor-BaseForm-cfg-taskStore'>    /**
</span>     * @cfg {Gnt.data.TaskStore} taskStore A store with tasks.
     *
     * **Note:** This is required option if task being loaded isn't yet belong to any task store.
     */
    taskStore               : null,

<span id='Gnt-widget-taskeditor-BaseForm-property-taskListeners'>    taskListeners           : null,
</span>
<span id='Gnt-widget-taskeditor-BaseForm-property-autoScroll'>    autoScroll              : true,
</span>
<span id='Gnt-widget-taskeditor-BaseForm-property-defaults'>    defaults                : {
</span>        labelWidth : 110
    },

<span id='Gnt-widget-taskeditor-BaseForm-property-bodyPadding'>    bodyPadding             : 5,
</span>
<span id='Gnt-widget-taskeditor-BaseForm-property-border'>    border                  : false,
</span><span id='Gnt-widget-taskeditor-BaseForm-property-layout'>    layout                  : 'anchor',
</span><span id='Gnt-widget-taskeditor-BaseForm-property-defaultType'>    defaultType             : 'textfield',
</span>
<span id='Gnt-widget-taskeditor-BaseForm-method-initComponent'>    initComponent : function () {
</span>        // if task provided on construction step
        if (this.task) {
            // get actual field names from task
            this.fieldNames = this.getFieldNames(this.task);
        }

        // if no fields definition provided we make default fields set
        if (!this.items) {
            this.buildFields();
        }

        this.callParent(arguments);

        if (this.task) {
            this.loadRecord(this.task, this.taskBuffer);
        }
    },

<span id='Gnt-widget-taskeditor-BaseForm-method-getFieldNames'>    getFieldNames : function (task) {
</span>        if (!task) return;

        var result = {};

        for (var i in this.fieldNames) {
            result[i] = task[i];
        }

        return result;
    },

<span id='Gnt-widget-taskeditor-BaseForm-method-renameFields'>    // Renames form fields according to provided task model.
</span>    renameFields : function (task) {
        var newFields   = this.getFieldNames(task);
        if (!newFields) return;

        var form    = this.getForm(),
            changed = false,
            field;

        for (var i in this.fieldNames) {
            field = form.findField(this.fieldNames[i]);

            // check if field name should be changed
            if (field &amp;&amp; newFields[i] &amp;&amp; newFields[i] != field.name) {
                changed     = true;
                field.name  = newFields[i];
            }
        }

        // if something was changed
        if (changed) {
            // keep new fields' names dictionary
            this.fieldNames = newFields;
        }
    },

<span id='Gnt-widget-taskeditor-BaseForm-method-setSuppressTaskUpdate'>    /**
</span>     * Suppress task updates invoking by form fields. Calls setSuppressTaskUpdate() of each field that supports this method.
     * @param {Boolean} state Suppress or allow task updating.
     */
    setSuppressTaskUpdate : function (state) {
        var fields  = this.getForm().getFields();

        fields.each(function (field) {
            // if field contains setTask() method
            field.setSuppressTaskUpdate &amp;&amp; field.setSuppressTaskUpdate(state);
        });
    },

<span id='Gnt-widget-taskeditor-BaseForm-method-isDataChanged'>    isDataChanged : function() {
</span>        return this.isDirty();
    },


<span id='Gnt-widget-taskeditor-BaseForm-method-buildTaskBuffer'>    buildTaskBuffer : function (task) {
</span>        var me  = this;

        me.taskBuffer             = task.copy();
        // since copy() doesn't copy taskStore let`s copy it ourself
        me.taskBuffer.taskStore   = task.taskStore;
    },


<span id='Gnt-widget-taskeditor-BaseForm-method-loadRecord'>    /**
</span>     * Loads an Gnt.model.Task into this form.
     * @param {Gnt.model.Task} task The record to edit.
     * @param {Gnt.model.Task} [taskBuffer] The record to be used as a buffer to keep changed values of fields which implement {@link Gnt.field.mixin.TaskField}
     * mixin interface. This parameter can be used in case when you want to implement two form instances instantly
     * reflecting changes of each other:
     *
     *      // create 1st TaskForm instance
     *      var taskForm = Ext.create('Gnt.widget.taskeditor.TaskForm');
     *      // load record into 1st form
     *      taskForm.loadRecord(someTask);
     *
     *      // create 2nd TaskForm instance
     *      var anotherForm = Ext.create('Gnt.widget.taskeditor.TaskForm');
     *      // load the same record into 2nd form
     *      // and set to share taskBuffer with 1st form to immediately refect changes of each other
     *      anotherForm.loadRecord(someTask, taskForm.taskBuffer);
     */
    loadRecord : function (task, taskBuffer) {
        var me          = this;

        // if new or another task loading
        if (task &amp;&amp; task !== me.task) {
            // let's rename form fields according to task model
            me.renameFields(task);
        }

        me.task         = task;
        me.taskBuffer   = taskBuffer;

        // if no pre-created taskBuffer provided, let`s create it
        if (!me.taskBuffer) {
            me.buildTaskBuffer(task);
        }

        // destroy previous task listeners if any
        me.taskListeners &amp;&amp; me.taskListeners.destroy();

        // listen to 'taskupdated' event and update fields &quot;readonly&quot; state
        me.taskListeners = me.mon(me.taskBuffer, {
            taskupdated : me.onTaskUpdated,
            destroyable : true,
            scope       : me
        });

        var form        = me.getForm();

        // following code is modified implementation
        // of Ext.form.Basic setValues() method
        form._record    = task;

        this.suspendLayouts();

        var data = task.getData();

        form.getFields().each(function (field) {
            if (field.getName() in data) {
                // if field contains setTask() method
                // we gonna use it since setTask() execute setValue()
                if (field.setTask) {
                    field.setTask(me.taskBuffer);
                } else {
                    // set field value
                    field.setValue(data[field.getName()]);
                    // and set its readOnly state depending on task.isEditable() result
                    me.updateFieldReadOnly(field);
                }

                if (form.trackResetOnLoad) {
                    field.resetOriginalValue();
                }
            }
        });

        this.resumeLayouts(true);

        this.fireEvent('afterloadrecord', this, task);
    },


<span id='Gnt-widget-taskeditor-BaseForm-method-updateFieldReadOnly'>    updateFieldReadOnly : function (field) {
</span>        var me = this;

        if (!field.disabled) {

            // editable = false requires special treatment
            if (field.editable === false) {
                // let's take into account Task.isEditable() result
                if (!me.taskBuffer.isEditable(field.name)) {
                    field.setReadOnly(true);

                    // when editable is false `readOnly` should be set to `true`
                } else if (field.inputEl) {
                    field.setReadOnly(false);
                    field.inputEl.dom.readOnly = true;
                }

            } else {
                // let's take into account Task.isEditable() result
                field.setReadOnly(!me.taskBuffer.isEditable(field.name));
            }
        }
    },


<span id='Gnt-widget-taskeditor-BaseForm-method-updateReadOnly'>    // Updates readonly state of all the form fields
</span>    updateReadOnly : function () {
        var me      = this,
            form    = me.getForm(),
            data    = me.taskBuffer.getData();

        form.getFields().each(function (field) {
            if (field.getName() in data &amp;&amp; !field.isTaskField) me.updateFieldReadOnly(field);
        });
    },


<span id='Gnt-widget-taskeditor-BaseForm-method-updateRecord'>    /**
</span>     * Applies the values from this form into the passed {@link Gnt.model.Task} object.
     * If the task is not specified, it will attempt to update (if it exists) the record provided to {@link #loadRecord}.
     * @param {Gnt.model.Task} [task] The record to apply change to.
     */
    updateRecord : function (task) {
        var me = this;

        task = task || me.task;

        if (task &amp;&amp; me.fireEvent('beforeupdaterecord', me, task, me.updateRecordFn) !== false) {
            me.setSuppressTaskUpdate(true);

            me.updateRecordFn.call(me, task);

            me.setSuppressTaskUpdate(false);
            me.fireEvent('afterupdaterecord', me, task);
            return true;
        }

        return false;
    },


<span id='Gnt-widget-taskeditor-BaseForm-method-updateRecordWithFieldValue'>    updateRecordWithFieldValue : function (task, field) {
</span>        var modelField = task.getField(field.name);

        // if the field has applyChanges() method
        // we use it to apply changes to the task
        if (field.applyChanges) {
            field.applyChanges(task);

        // if there is a matching model field and the form field is supposed to be submittable (not displayfield or smth)
        } else if (modelField &amp;&amp; field.name in this.getForm().getFieldValues()) {
            task.set(field.name, field.getValue());
        }
    },


<span id='Gnt-widget-taskeditor-BaseForm-method-updateRecordFn'>    /**
</span>     * A function that iterates the form fields and applies to changes to it. Override this function for custom logic.
     * @param task
     */
    updateRecordFn : function (task) {
        var me      = this;

        task.beginEdit();

        me.getForm().getFields().each(function (field) {
            me.updateRecordWithFieldValue(task, field);
        });

        task.endEdit();
    },


<span id='Gnt-widget-taskeditor-BaseForm-method-initFieldDefinition'>    // Applies &quot;task&quot;, &quot;taskStore&quot;, &quot;highlightTaskUpdates&quot; and &quot;readOnly&quot; configs to a field
</span>    initFieldDefinition : function (field, cfg) {
        var me              = this;

        var commonParams    = {
            taskStore               : me.taskStore,
            task                    : me.task,
            highlightTaskUpdates    : me.highlightTaskUpdates
        };

        // if field isn't already read only then let's take into account Task.isEditable() result
        if (!field.readOnly &amp;&amp; me.task) {
            commonParams.readOnly   = !me.task.isEditable(field.name);
        }

        return Ext.apply(field, commonParams, cfg);
    },


<span id='Gnt-widget-taskeditor-BaseForm-method-getTaskFieldValue'>    // Gets the task field value
</span>    getTaskFieldValue : function (field) {
        var me      = this,
            task    = this.task;

        return task ? task.get(me.fieldNames[field]) : '';
    },


<span id='Gnt-widget-taskeditor-BaseForm-method-onTaskUpdated'>    onTaskUpdated : function (task, field) {
</span>        // let's update fields &quot;readonly&quot; status after task data has been modified
        this.updateReadOnly();
    }

});
</pre>
</body>
</html>
