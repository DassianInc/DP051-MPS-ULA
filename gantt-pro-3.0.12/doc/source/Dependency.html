<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Gnt-field-Dependency'>/**
</span>@class Gnt.field.Dependency
@extends Ext.form.field.Text

A specialized field allowing a user to change the dependencies of a task. The type of dependecies
created by this field is controlled by the {@link #type} config.

The text describing a dependency can be one or more values in the following format, separated with a {@link #separator} string:

    [TaskId][DependencyType][Lag]

where:

- `TaskId` is the id of the predecessor/successor task, can be a &quot;real&quot; or &quot;sequential&quot; id, see below.
- `DependencyType` (optional, default value is &quot;FS&quot;) is one of the following (based on the {@link Gnt.util.DependencyParser#l10n}) property.
* **Please note** that dependency types are localized and depend on selected language (following values present English translation):
    - `FS` - for &quot;Finish-To-Start&quot;
    - `FF` - for &quot;Finish-To-Finish&quot;
    - `SF` - for &quot;Start-To-Finish&quot;
    - `SS` - for &quot;Start-To-Start&quot;
- `Lag` (optional). Should start with `+` or `-` followed by a number indicating the lag amount
and duration unit.


The `TaskId` part can contain either &quot;real&quot; id of the task (the id that is stored in the database) or &quot;sequential&quot; id.
The sequential id corresponds to the ordinal position of the task in the whole dataset. When you add or remove tasks
from the dataset, the sequential id of the tasks may change. Which type of id is used is controled by the
{@link #useSequenceNumber} config.

For example:
    10          - Finish to start dependency from task with Id 10
    10SS        - Start to start dependency from task with Id 10
    3FS+1d      - Finish to start dependency from task with Id 3, with +1 day lag
    3FS-10h      - Finish to start dependency from task with Id 3, with -10 hours lag

*/
Ext.define(&quot;Gnt.field.Dependency&quot;, {
    extend              : &quot;Ext.form.field.Text&quot;,

    alternateClassName  : &quot;Gnt.widget.DependencyField&quot;,
    alias               : &quot;widget.dependencyfield&quot;,

    requires            : ['Gnt.util.DependencyParser'],

    mixins              : ['Gnt.mixin.Localizable'],

<span id='Gnt-field-Dependency-cfg-type'>    /**
</span>     * @cfg {String} type Either `predecessors` or `successors`. Defines the type of dependencies managed by this field. Defaults to 'predecessors'.
     */
    type                : 'predecessors',        // Or successors

<span id='Gnt-field-Dependency-cfg-separator'>    /**
</span>     * @cfg {String} separator A separator between the dependency values in the text field.
     */
    separator           : ';',

<span id='Gnt-field-Dependency-property-task'>    task                : null,
</span>
<span id='Gnt-field-Dependency-property-dependencyParser'>    /**
</span>     * @property {Gnt.util.DependencyParser} dependencyParser
     * An object used to parse entered string to a proper dependency data.
     * **See also** {@link #dependencyParserConfig} config.
     */
    dependencyParser    : null,

<span id='Gnt-field-Dependency-cfg-dependencyParserConfig'>    /**
</span>     * @cfg {Object} dependencyParserConfig
     * A config object to be passed to {@link Gnt.util.DependencyParser} constructor.
     */
    dependencyParserConfig  : null,

<span id='Gnt-field-Dependency-cfg-l10n'>    /**
</span>     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - invalidFormatText   : 'Invalid dependency format',
            - invalidDependencyText : 'Invalid dependency found, please make sure you have no cyclic paths between your tasks',
            - invalidDependencyType : 'Invalid dependency type {0}. Allowed values are: {1}.'
     */

<span id='Gnt-field-Dependency-cfg-useSequenceNumber'>    /**
</span>     * @cfg {Boolean} useSequenceNumber Set to `true` to use auto-generated sequential identifiers
     * to reference other tasks (see {@link Gnt.model.Task#getSequenceNumber} for definition).
     * If value is `false`then &quot;real&quot; id (that is stored in the database) will be used.
     */
    useSequenceNumber : false,

<span id='Gnt-field-Dependency-method-constructor'>    constructor         : function(config) {
</span>        var me = this;
        Ext.apply(this, config);

        this.dependencyParser = new Gnt.util.DependencyParser(Ext.apply({
            // Since we're reusing the NumberField's parsing of numbers, we have to pass this on to the parser
            // to avoid having the same definitions in the parser too
            parseNumberFn : function() { return Gnt.widget.DurationField.prototype.parseValue.apply(me, arguments); }
        }, this.dependencyParserConfig));

        this.callParent(arguments);

        this.addCls('gnt-field-dependency');
    },


<span id='Gnt-field-Dependency-method-isPredecessor'>    isPredecessor : function() {
</span>        return this.type === 'predecessors';
    },

<span id='Gnt-field-Dependency-method-setTask'>    /**
</span>     * Set the task this field is bound to.
     *
     * @param {Gnt.model.Task} task
     */
    setTask : function(task) {
        this.task   = task;
        this.setRawValue(this.getFieldDisplayValue(task));
    },

<span id='Gnt-field-Dependency-method-getDependencies'>    /**
</span>     * Returns an array of dependency objects representing the current value of the field:

        [
            {
                taskId  : 3,    // Int, always present
                type    : &quot;FS&quot;, // String, always present
                lag     : 3,    // Int, optional
                lagUnit : 'd'   // String, optional
            },
            ...
        ]

     * @return {Object} The dependencies
     */
    getDependencies: function () {
        return this.dependencyParser.parse(this.getRawValue());
    },


<span id='Gnt-field-Dependency-method-getTaskIdFromDependency'>    getTaskIdFromDependency : function (dependencyData) {
</span>        var store = this.task.getTaskStore(),
            taskId = dependencyData.taskId,
            task;

        if (this.useSequenceNumber) {
            task = store.getBySequenceNumber(taskId);
            taskId = task &amp;&amp; task.getId();
        }

        return taskId;
    },


<span id='Gnt-field-Dependency-method-getErrors'>    getErrors : function (value) {
</span>        if (!value) return [];

        var parsed   = this.dependencyParser.parse(value);

        if (!parsed) {
            return [ this.L('invalidFormatText') ];
        }

        var dependencies    = this.getDependencies(),
            isPredecessor   = this.isPredecessor(),
            task            = this.task,
            dependencyStore = task.getTaskStore().dependencyStore,
            // existing dependencies
            oldDependencies = task[isPredecessor ? 'predecessors' : 'successors'],
            typeAbbrs       = this.dependencyParser.types,
            allowedTypes    = dependencyStore.allowedDependencyTypes,
            typeCodes       = dependencyStore.model.Type,
            taskId;

        // build list of tasks to be created, we need to provide it to isValidDependency() for correct validation
        var newDeps    = [];

        for (var i = 0; i &lt; dependencies.length; i++) {
            var depData = dependencies[i];

            taskId      = this.getTaskIdFromDependency(depData);
            if (!taskId) {
                return [ this.L('invalidDependencyText') ];
            }

            // validate dependency type used
            if (dependencyStore.allowedDependencyTypes &amp;&amp; !dependencyStore.isValidDependencyType(depData.type)) {
                var allowed         = '';

                for (var j = 0, k = allowedTypes.length; j &lt; k; j++) {
                    allowed += typeAbbrs[typeCodes[allowedTypes[j]]] + ',';
                }

                return [ Ext.String.format(this.L('invalidDependencyType'), typeAbbrs[depData.type], allowed.substring(0, allowed.length-1)) ];
            }

            var dep     = new dependencyStore.model();

            dep.setSourceId(isPredecessor ? taskId : task.getId());
            dep.setTargetId(isPredecessor ? task.getId() : taskId);
            dep.setType(depData.type);
            dep.setLag(depData.lag);
            dep.setLagUnit(depData.lagUnit);

            newDeps.push(dep);
        }

        // loop over dependencies to be created
        for (i = 0; i &lt; newDeps.length; i++) {
            // validate dependency: we ask store if `newDeps[i]` is valid if we remove `oldDependencies` and add `newDeps` dependencies
            if (!dependencyStore.isValidDependency(newDeps[i], newDeps, oldDependencies)) {
                return [ this.invalidDependencyText ];
            }
        }

        return this.callParent([ parsed.value ]);
    },

<span id='Gnt-field-Dependency-method-getFieldDisplayValue'>    getFieldDisplayValue    : function (task) {
</span>
        var isPredecessor   = this.isPredecessor(),
            deps            = isPredecessor ? task.getIncomingDependencies(true) : task.getOutgoingDependencies(true),
            dpTypes         = this.dependencyParser.types,
            endToStart      = Gnt.model.Dependency.Type.EndToStart,
            strings         = [],
            depTask;

        for (var i = 0; i &lt; deps.length; i++) {
            var dep     = deps[i];

            depTask     = isPredecessor ? dep.getSourceTask() : dep.getTargetTask();

            if (depTask &amp;&amp; dep.isValid(false)) {
                var type        = dep.getType(),
                    lag         = dep.getLag(),
                    lagUnit     = dep.getLagUnit();

                strings.push(Ext.String.format(
                    '{0}{1}{2}{3}{4}',
                    this.useSequenceNumber ? depTask.getSequenceNumber() : depTask.getId(),
                    lag || type !== endToStart ? dpTypes[type] : '',
                    lag &gt; 0 ? '+' : '',
                    lag || '',
                    lag &amp;&amp; lagUnit !== 'd' ? lagUnit : '')
                );
            }
        }

        return strings.join(this.separator);
    },

<span id='Gnt-field-Dependency-method-isDirty'>    isDirty : function (task) {
</span>        task            = task || this.task;
        if (!task) return false;

        var isPredecessor   = this.isPredecessor(),
            depStore        = task.getTaskStore().dependencyStore,
            deps            = isPredecessor ? task.getIncomingDependencies() : task.getOutgoingDependencies(),
            taskId          = task.getId();

        // check if some of task dependencies are dirty
        for (var i = 0, l = deps.length; i &lt; l; i++) {
            if (deps[i].dirty || deps[i].phantom) return true;
        }

        if (depStore) {
            var fn  = isPredecessor ? 'getTargetId' : 'getSourceId';

            // check if there are some unsaved removed dependencies
            deps    = depStore.getRemovedRecords();
            for (i = 0, l = deps.length; i &lt; l; i++) {
                if (deps[i][fn]() == taskId) return true;
            }
        }

        return false;
    },

<span id='Gnt-field-Dependency-method-applyChanges'>    /**
</span>     * This method applies the changes from the field to the bound task or to the task provided as 1st argument.
     *
     * @param {Gnt.model.Task} [task] The task to apply the changes to. If not provided, changes will be applied to the last bound task
     * (with {@link #task} config option or {@link #setTask) method)
     */
    applyChanges : function(task) {
        task = task || this.task;

        var depStore      = task.getTaskStore().dependencyStore,
            dependencies  = this.getDependencies(),
            isPredecessor = this.isPredecessor(),
            currentDeps   = isPredecessor ? task.getIncomingDependencies(true) : task.getOutgoingDependencies(true),
            toRemove      = [],
            i;

        var ids = Ext.Array.map(dependencies, function(dep){
             return this.getTaskIdFromDependency(dep);
        }, this);

        // First remove deleted dependencies
        for (i = 0; i &lt; currentDeps.length; i++) {
            if (!Ext.Array.contains(ids, currentDeps[i][isPredecessor ? 'getSourceId' : 'getTargetId']())) {
                toRemove.push(currentDeps[i]);
            }
        }
        if (toRemove.length &gt; 0) {
            depStore.remove(toRemove);
        }

        var toAdd = [];

        // Now iterate cell value, to update or add new dependencies
        for (i = 0; i &lt; dependencies.length; i++) {
            var depData = dependencies[i];
            var predId = this.getTaskIdFromDependency(depData);
            var dep = depStore.getByTaskIds(predId, task.getId());

            if (dep) {
                dep.beginEdit();
                dep.setType(depData.type);
                dep.setLag(depData.lag);
                dep.setLagUnit(depData.lagUnit);
                dep.endEdit();
            } else {
                dep = new depStore.model();

                dep.setSourceId(isPredecessor ? predId : task.getId());
                dep.setTargetId(isPredecessor ? task.getId() : predId);
                dep.setType(depData.type);
                dep.setLag(depData.lag);
                dep.setLagUnit(depData.lagUnit);

                toAdd.push(dep);
            }
        }

        if (toAdd.length &gt; 0) {
            depStore.add(toAdd);
        }
    }
});
</pre>
</body>
</html>
